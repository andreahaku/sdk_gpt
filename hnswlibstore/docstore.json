[["0",{"pageContent":"# JavaScript\n\nThe JavaScript version of the MetaMask SDK enables all JavaScript-based apps to easily connect with a MetaMask wallet client. It supports:\n\n- [React](/metamask-sdk-js/metamask-sdk-react.html)\n- [Other web frameworks](/metamask-sdk-js/metamask-sdk-other-frameworks.html)\n- [Pure javascript](/metamask-sdk-js/metamask-sdk-pure-javascript.html)\n- [React Native](/metamask-sdk-js/metamask-sdk-react-native.html)\n- [NodeJS](/metamask-sdk-js/metamask-sdk-nodejs.html)\n- [Electron](/metamask-sdk-js/metamask-sdk-electron.html)\n\nTo install, import, instantiate and use the SDK, see the [getting started section](#getting-started). Deviations from the standard are highlighted on each of the supported frameworks.","metadata":{"source":"README copy"}}],["1",{"pageContent":"Getting started\n\n### 1. Install a MetaMask Mobile version compatible with the SDK\n\nIn order to test the MetaMask SDK, developers need access to a MetaMask Mobile build that is compatible with the SDK. Please install MetaMask Mobile v5.8.1 or above.\n\n### 2. Install the SDK\n\n```bash\nyarn add @metamask/sdk\nor\nnpm i @metamask/sdk\n```\n\n### 3. Import the SDK\n\n```javascript\nimport MetaMaskSDK from '@metamask/sdk';\n```\n\n### 4. Instantiate the SDK\n\nFor all Javascript-based apps, instantiate the SDK like this:\n\n```javascript\nconst MMSDK = new MetaMaskSDK(options);\n\nconst ethereum = MMSDK.getProvider(); // You can also access via window.ethereum\n```\n\nFor a list of possible `options` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\n### 5. Use the SDK\n\n```javascript\nethereum.request({ method: 'eth_requestAccounts', params: [] });\n```\n\nYou should always call `eth_requestAccounts` first!\n\nFor possible methods, check [the Ethereum Provider API](/ethereum-provider.html)","metadata":{"source":"README copy"}}],["2",{"pageContent":"interface WatchAssetParams {\n  type: 'ERC20'; // In the future, other standards will be supported\n  options: {\n    address: string; // The address of the token contract\n    'symbol': string; // A ticker symbol or shorthand, up to 11 characters\n    decimals: number; // The number of token decimals\n    image: string; // A string url of the token logo\n  };\n}","metadata":{"source":"WatchAssetParams"}}],["3",{"pageContent":"# Accessing Accounts\n\nUser accounts are used in a variety of contexts in Ethereum, including as identifiers and for signing transactions. In order to request a signature from the user or have the user approve a transaction, one must be able to access the user's accounts. The `wallet methods` below involve a signature or transaction approval and all require the sending account as a function parameter.\n\n- `eth_sendTransaction`\n- `eth_sign` (insecure and unadvised to use)\n- `personal_sign`\n- `eth_signTypedData`\n\nOnce you've [connected to a user](./getting-started.html), you can always re-check the current account by checking `ethereum.selectedAddress`.\n\n**Example:**\n<ChangeAccount />\n\nIf you'd like to be notified when the address changes, we have an event you can subscribe to:\n\n```javascript\nethereum.on('accountsChanged', function (accounts) {\n  // Time to reload your interface with accounts[0]!\n});","metadata":{"source":"accessing-accounts"}}],["4",{"pageContent":"If the first account in the returned array isn't the account you expected, you should notify the user!\nIn the future, the accounts array may contain more than one account. This functionality isn't available yet. The first account in the array will always be considered the user's \"selected\" account.","metadata":{"source":"accessing-accounts"}}],["5",{"pageContent":"# Common Terms\n\n## Words are Hard\n\nEvery field has its terminology, and every specialization has its acronyms. You can't escape it.\n\nThe decentralized web is certainly no exception, and if you're new to Web3, take a gander at MetaMask's [introduction to blockchain article](https://metamask.zendesk.com/hc/en-us/articles/360015489611) in our knowledgebase.\n\nAnd no matter what your experience level, bookmark [ConsenSys' blockchain glossary](https://consensys.net/knowledge-base/a-blockchain-glossary-for-beginners/), an amalgamation of many sources of information that is regularly updated.\n\nWhile the above glossary is in the process of being translated, you can read an older version of this glossary in Spanish [consulte aquí una versión antigua de este glosario en español](https://github.com/faraggi/words-are-hard-es/blob/master/words-are-hard-es.md), thanks to [faraggi](https://github.com/faraggi).","metadata":{"source":"common-terms"}}],["6",{"pageContent":"# Contributors\n\n## MetaMask Repositories\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab Extension\n\n<GithubContributor\n  repoName=\"metamask-extension\"\n/>\n\n:::\n\n::: tab Mobile\n\n<GithubContributor\n  repoName=\"metamask-mobile\"\n/>\n\n:::\n\n::: tab Documentation\n\n<GithubContributor\n  repoName=\"metamask-docs\"\n/>\n\n:::\n\n::::","metadata":{"source":"contributors"}}],["7",{"pageContent":"# Defining Your App's Icon\n\nWhen your site makes a login request to a MetaMask user, MetaMask may render a modal that display's your site icon.\n\nWe retrieve this icon using the HTML selector `<head> link[rel=\"shortcut icon\"]`, so to customize this icon for your site, just make sure to follow the [favicon standard](https://en.wikipedia.org/wiki/Favicon), and make sure to have a `link` tag within your site's `head` with `rel = \"shortcut icon\"`, like this.\n\nThe tag's `href` attribute will be used for assigning the site icon.\n\n```html\n<head>\n  <link rel=\"shortcut icon\" href=\"https://your-site.com/your-icon.png\" />\n</head>\n```","metadata":{"source":"defining-your-icon"}}],["8",{"pageContent":"/*****************************************/\n/* Detect the MetaMask Ethereum provider */\n/*****************************************/\n\nimport detectEthereumProvider from '@metamask/detect-provider';\n\n// this returns the provider, or null if it wasn't detected\nconst provider = await detectEthereumProvider();\n\nif (provider) {\n  startApp(provider); // Initialize your app\n} else {\n  console.log('Please install MetaMask!');\n}\n\nfunction startApp(provider) {\n  // If the provider returned by detectEthereumProvider is not the same as\n  // window.ethereum, something is overwriting it, perhaps another wallet.\n  if (provider !== window.ethereum) {\n    console.error('Do you have multiple wallets installed?');\n  }\n  // Access the decentralized web!\n}\n\n/**********************************************************/\n/* Handle chain (network) and chainChanged (per EIP-1193) */\n/**********************************************************/","metadata":{"source":"handleProvider"}}],["9",{"pageContent":"/**********************************************************/\n/* Handle chain (network) and chainChanged (per EIP-1193) */\n/**********************************************************/\n\nconst chainId = await ethereum.request({ method: 'eth_chainId' });\n// Do something with the chainId\n\nethereum.on('chainChanged', handleChainChanged);\n\nfunction handleChainChanged(_chainId) {\n  // We recommend reloading the page, unless you must do otherwise\n  window.location.reload();\n}\n\n/***********************************************************/\n/* Handle user accounts and accountsChanged (per EIP-1193) */\n/***********************************************************/\n\nlet currentAccount = null;\nethereum\n  .request({ method: 'eth_accounts' })\n  .then(handleAccountsChanged)\n  .catch((err) => {\n    // Some unexpected error.\n    // For backwards compatibility reasons, if no accounts are available,\n    // eth_accounts will return an empty array.\n    console.error(err);\n  });","metadata":{"source":"handleProvider"}}],["10",{"pageContent":"// Note that this event is emitted on page load.\n// If the array of accounts is non-empty, you're already\n// connected.\nethereum.on('accountsChanged', handleAccountsChanged);\n\n// For now, 'eth_accounts' will continue to always return an array\nfunction handleAccountsChanged(accounts) {\n  if (accounts.length === 0) {\n    // MetaMask is locked or the user has not connected any accounts\n    console.log('Please connect to MetaMask.');\n  } else if (accounts[0] !== currentAccount) {\n    currentAccount = accounts[0];\n    // Do any other work!\n  }\n}\n\n/*********************************************/\n/* Access the user's accounts (per EIP-1102) */\n/*********************************************/","metadata":{"source":"handleProvider"}}],["11",{"pageContent":"/*********************************************/\n/* Access the user's accounts (per EIP-1102) */\n/*********************************************/\n\n// You should only attempt to request the user's accounts in response to user\n// interaction, such as a button click.\n// Otherwise, you popup-spam the user like it's 1999.\n// If you fail to retrieve the user's account(s), you should encourage the user\n// to initiate the attempt.\ndocument.getElementById('connectButton', connect);","metadata":{"source":"handleProvider"}}],["12",{"pageContent":"// While you are awaiting the call to eth_requestAccounts, you should disable\n// any buttons the user can click to initiate the request.\n// MetaMask will reject any additional requests while the first is still\n// pending.\nfunction connect() {\n  ethereum\n    .request({ method: 'eth_requestAccounts' })\n    .then(handleAccountsChanged)\n    .catch((err) => {\n      if (err.code === 4001) {\n        // EIP-1193 userRejectedRequest error\n        // If this happens, the user rejected the connection request.\n        console.log('Please connect to MetaMask.');\n      } else {\n        console.error(err);\n      }\n    });\n}","metadata":{"source":"handleProvider"}}],["13",{"pageContent":"# Initializing Dapps\n\nOnce you have your basic dev environment [set up](./Getting-Started), you are ready to start interacting with some smart contracts. There are some basic things you'll need, regardless of what convenience library you're using, when communicating with a smart contract:","metadata":{"source":"initializing-dapps"}}],["14",{"pageContent":"The Contract Network\n\nIf you aren't connected to the right network, you aren't going to have any luck sending transactions to your contract, so make sure you have this right! Many dapp developers choose to deploy their contract to a testnet first, in order to avoid potentially disastrous fees if something goes wrong during development and testing on mainnet.\n\nNo matter which network you deploy your final dapp on, your user will need to be able to access it. MetaMask makes available [wallet_switchEthereumChain](https://docs.metamask.io/guide/rpc-api.html#other-rpc-methods), as well as [wallet_addEthereumChain](https://docs.metamask.io/guide/rpc-api.html#wallet-addethereumchain), which allows you to prompt the user to add a chain that you suggest, and switch to it using a confirmation dialogue.","metadata":{"source":"initializing-dapps"}}],["15",{"pageContent":"The Contract Address\n\nEvery account in Ethereum has an address, whether it's an external key-pair account, or a smart contract. In order for any smart contract library to communicate with your contracts, they'll need to know its exact address. If you deployed a contract, you probably know how to find the address, but if you're just getting started, check out our Knowledgebase [explainer on finding contract addresses.](https://metamask.zendesk.com/hc/en-us/articles/360059683451-How-to-view-or-add-custom-token-contract-address)","metadata":{"source":"initializing-dapps"}}],["16",{"pageContent":"The Contract ABI\n\nIn Ethereum, [The ABI Specification](https://solidity.readthedocs.io/en/develop/abi-spec.html) is a way to encode the interface of a smart contract in a way that is comprehensible to your user interface.\nIt is an array of method-describing objects, and when you feed this and the address into a contract-abstraction library, this `ABI` tells those libraries about what methods to provide, and how to compose transactions to call those methods.\n\nExample libraries include:\n\n- [ethers](https://www.npmjs.com/package/ethers)\n- [web3.js](https://www.npmjs.com/package/web3)\n- [Embark](https://framework.embarklabs.io/)\n- [ethjs](https://www.npmjs.com/package/ethjs)\n- [truffle](https://www.trufflesuite.com/)","metadata":{"source":"initializing-dapps"}}],["17",{"pageContent":"The Contract Bytecode\n\nIf your web app is going to publish a new smart contract that is pre-compiled, it may need to include some `bytecode`. In this case, you will not know the contract address in advance, but instead will have to publish, watch for the transaction to be processed, and then extract the final contract's address from the completed transaction.\n\nIf publishing a contract from bytecode, you will still want an `ABI` if you want to interact with it! The bytecode does not describe how to interact with the final contract.\n\n## The Contract Source Code\n\nIf your website is going to allow users to edit smart contract source code and compile it, like [Remix](http://remix.ethereum.org/), you may import a whole compiler. In this case you're going to derive your bytecode and ABI from that source code, and eventually you will derive the contract's address from the completed transaction, where that bytecode is published.","metadata":{"source":"initializing-dapps"}}],["18",{"pageContent":"# MetaMask Extension Provider\n\nA module for accessing the user's MetaMask [provider](https://github.com/ethereum/wiki/wiki/JavaScript-API#web3currentprovider) from other WebExtensions.\n\nThe account provided by this provider will be the user's MetaMask account.\n\nWhen sending signing requests to this provider, MetaMask will prompt the user to sign with their accounts.\n\nWorks in:\n\n- Chrome\n- Firefox\n\n## Installation\n\nUsing npm as a package manager:\n\n```bash\nnpm install metamask-extension-provider -s\n```\n\n## Usage\n\nUsing a bundler like browserify:\n\n```javascript\nconst createMetaMaskProvider = require('metamask-extension-provider');\n\nconst provider = createMetaMaskProvider();\n\nprovider.on('error', (error) => {\n  // Failed to connect to MetaMask, fallback logic.\n});\n\n// Enjoy!\n```","metadata":{"source":"metamask-extension-provider"}}],["19",{"pageContent":"Adding additional browser support\n\nAdd MetaMask's extension ID for that browser's store to the config file.\n\n```javascript\n{\n  \"CHROME_ID\": \"nkbihfbeogaeaoehlefnkodbefgpgknn\",\n  \"FIREFOX_ID\": \"webextension@metamask.io\"\n}\n```\n\n## Running the example\n\nUse the `./sample-extension` folder as an WebExtension. You can easily add it to Chrome or Firefox Developer Edition.\n\n## Editing the example\n\nYou must have `browserify` installed (`npm i -g browserify`).\n\nYou can edit the sample file `sample-extension/index.js` and then rebuild the file with `npm run buildSample`.\n\n## Using with a local Development copy of MetaMask\n\nYou'll need to edit the method `getMetaMaskId()` to return your local development MetaMask's id. You can get that from your MetaMask console with `chrome.runtime.id`.","metadata":{"source":"metamask-extension-provider"}}],["20",{"pageContent":"Current Limitations\n\nIn order to identify when there is a problem (like MetaMask was not connected), some kind of proper error handling must be added to [metamask-inpage-provider](https://github.com/MetaMask/metamask-inpage-provider) that exposes the errors to the consumer of the provider. Maybe making it an event-emitter, so it can emit its errors, instead of just logging them.","metadata":{"source":"metamask-extension-provider"}}],["21",{"pageContent":"# Electron\n\nThe MetaMask SDK for Electron should work exactly the same as for web apps if you are using it on the frontend and it should work exactly the same as nodeJS if you are using it on the backend, so please check:\n\n- For frontend, [check the web apps section](metamask-sdk-react.html)\n- For backend, [check the nodeJS section](metamask-sdk-nodejs.html)","metadata":{"source":"metamask-sdk-electron"}}],["22",{"pageContent":"# Gaming\n\n## Unity\n\nFor all instructions on how to install and use Unity SDK, please check [this section](metamask-sdk-unity.html).\n\n\n## Unreal Engine\n\nComing soon. We are working on a MetaMask SDK for Unreal Engine and will post updates soon.","metadata":{"source":"metamask-sdk-gaming"}}],["23",{"pageContent":"# Welcome\n\nMetaMask SDK provides an easy to use library for reliable, secure, seamless connection for your dapp to MetaMask extension and mobile.\n\nDapps commonly access the MetaMask Extension from a desktop browser, or MetaMask Mobile from the in-app browser. However, up till now, native mobile and desktop apps, games, and web apps on mobile browsers have struggled to connect to a MetaMask wallet.\n\nOur goal is to enable delightful user experiences for your apps that are built for diverse communities of users and use-cases, and compatible with various platforms (mobile apps, desktop apps, web-apps).\n\nThe MetaMask SDK is a library that can be installed by developers in their projects and will automatically guide their users to easily connect with a MetaMask wallet client.\n\n:::tip\nThe MetaMask SDK instance returns the [`ethereum` web3 provider](/ethereum-provider.html) that developers are already used to, so existing dapps should work out of the box with the SDK!\n:::","metadata":{"source":"metamask-sdk-intro"}}],["24",{"pageContent":"Example use cases\n\n- Dapps running on a desktop browser: the MetaMask SDK checks if the MetaMask wallet browser extension is available and, if not, it prompts the user to install it or to connect via QR code with their MetaMask Mobile wallet.\n- Native mobile applications: the MetaMask SDK automatically deeplinks to the user's MetaMask Mobile wallet to make the connection.","metadata":{"source":"metamask-sdk-intro"}}],["25",{"pageContent":"Platforms supported\n\n- [Javascript](/metamask-sdk-js)\n  - [Web apps](/metamask-sdk-js/metamask-sdk-react.html)\n    - [ReactJS](/metamask-sdk-js/metamask-sdk-react.html)\n    - [Other web Framworks](/metamask-sdk-js/metamask-sdk-other-frameworks.html)\n    - [Pure javascript](/metamask-sdk-js/metamask-sdk-pure-javascript.html)\n  - [React Native](/metamask-sdk-js/metamask-sdk-react-native.html)\n  - [NodeJS](/metamask-sdk-js/metamask-sdk-nodejs.html)\n  - [Electron](/metamask-sdk-js/metamask-sdk-electron.html)\n- [Mobile native apps](metamask-sdk-mobile.html#mobile)\n  - [Android (coming soon)](metamask-sdk-mobile.html#android)\n  - [iOS (coming soon)](metamask-sdk-mobile.html#ios)\n  - [React Native](/metamask-sdk-js/metamask-sdk-react-native.html)\n- [Gaming](metamask-sdk-gaming.html#gaming)\n  - [Unity](metamask-sdk-unity.html)\n  - [Unreal Engine (coming soon)](metamask-sdk-gaming.html#unreal-engine)","metadata":{"source":"metamask-sdk-intro"}}],["26",{"pageContent":"# Known Issues & Future Work\n\n## Known Issues\n\n* Sometimes the connection gets paused when the MetaMask Mobile app is in background and is not resumed properly once the app is opened again. Sometimes the users needs to go back to the dapp so that the request gets sent again. We are working on this and believe if we implement a new protocol that holds state like Waku, this could be solved in a better way.\n\n## Future Work\n\n* Improve the SDK and add new capabilities based on the feedback from the developer community.\n* Research implementing Waku or another similar decentralized communication solution.\n* Pause connection on React Native apps once they go to background to accomodate OS restrictions so the apps don't get terminated.\n* Create `metamask-react-sdk` and `metamask-react-native-sdk` packages that will make the installation of the SDK on React and React Native apps much easier. This will include hooks and other helpers to make it even easier to use.","metadata":{"source":"metamask-sdk-known-issues-future-work"}}],["27",{"pageContent":"# Mobile apps\n\n## iOS\n\nFor Native iOS apps please check [this section](/metamask-sdk-ios.html).\n\n## Android\n\nComing soon. We are working on a MetaMask SDK for Android native apps and will post updates soon.\n\nIf you are using React Native please check [this section](/metamask-sdk-js/metamask-sdk-react-native.html).\n\n## React Native\n\nFor React Native apps please check [this section](/metamask-sdk-js/metamask-sdk-react-native.html).","metadata":{"source":"metamask-sdk-mobile"}}],["28",{"pageContent":"# NodeJS\n\nYou can import the MetaMask SDK into your nodeJS application to enable users to easily connect with their MetaMask Mobile wallet.\n\nThe SDK will render a QR code on the console which users can scan with their MetaMask Mobile app and now you can use all the [`ethereum` methods available](/ethereum-provider.html) right from your nodeJS app!\n\n### 1. Install a MetaMask Mobile version compatible with the SDK\n\nIn order to test the MetaMask SDK, developers need access to a MetaMask Mobile build that is compatible with the SDK. Please install MetaMask Mobile v5.8.1 or above.\n\n### 2. Install the SDK\n\n```bash\nyarn add @metamask/sdk\nor\nnpm i @metamask/sdk\n```\n\n### 3. Import the SDK\n\n```javascript\nimport MetaMaskSDK from '@metamask/sdk';\n```","metadata":{"source":"metamask-sdk-nodejs"}}],["29",{"pageContent":"2. Install the SDK\n\n```bash\nyarn add @metamask/sdk\nor\nnpm i @metamask/sdk\n```\n\n### 3. Import the SDK\n\n```javascript\nimport MetaMaskSDK from '@metamask/sdk';\n```\n\n### 4. Instantiate the SDK\n\nFor all Javascript-based apps, instantiate the SDK like this:\n\n```javascript\nconst MMSDK = new MetaMaskSDK(options);\n\nconst ethereum = MMSDK.getProvider(); // You can also access via window.ethereum\n```\n\nFor a list of possible `options` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\n### 5. Use the SDK\n\n```javascript\nethereum.request({ method: 'eth_requestAccounts', params: [] });\n```\n\n:::tip\nYou should always call `eth_requestAccounts` first--that is what makes the SDK render the QR code on the console!\n\nFor other possible methods, check [the Ethereum Provider API](/ethereum-provider.html)\n:::\n\n### Recordings\n\n- [NodeJS app](https://recordit.co/2EiY8fQh48)","metadata":{"source":"metamask-sdk-nodejs"}}],["30",{"pageContent":"Recordings\n\n- [NodeJS app](https://recordit.co/2EiY8fQh48)\n\n### Examples\n\n- [NodeJS example](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/downloads/nodejs_v0.0.1_beta5.zip)\n\n#### Install the example: `yarn`\n\n#### Run the example: `node .`","metadata":{"source":"metamask-sdk-nodejs"}}],["31",{"pageContent":"# Support\n\nFor support please join our discord channel:\n\n[https://discord.gg/xsaNGpxrQa](https://discord.gg/xsaNGpxrQa)","metadata":{"source":"metamask-sdk-support"}}],["32",{"pageContent":"# Site Compatibility Checklist\n\n- Ensure that your site is compatible with the [MetaMask Ethereum provider API](./ethereum-provider.html) and review the [MetaMask Mobile best practices](./mobile-best-practices.html)\n\n- Include MetaMask Mobile as a listed wallet in your application, and link to open the MetaMask Mobile app (if installed) or to go to the app store (if not yet installed)\n  - We recommend adding a `Connect With MetaMask` button and using [deeplinks](https://metamask.github.io/metamask-deeplinks/)\n  - For more information about deeplinks, please see the [deeplinking documentation](./mobile-best-practices.html#deeplinking)\n\nPlease direct your users to either the relevant app store listing or to [the MetaMask homepage](https://metamask.io/download.html) to download MetaMask Mobile\n\n## Web3 Site UI Libraries\n\nInstead of creating your own `Connect With MetaMask` button here are a couple of options:\n\n- [Decentraland UI](https://ui.decentraland.org/?path=/story/atlas--uncontrolled)","metadata":{"source":"site-compatibility-checklist"}}],["33",{"pageContent":"/**\n * Getting Accounts\n */\n\n// window.web3\nconst accounts = web3.eth.accounts;\n\n// window.ethereum\nconst accounts = await ethereum.request({ method: 'eth_accounts' });\n\n/**\n * Sending a Transaction\n */\n\n// window.web3\nweb3.eth.sendTransaction(\n  {\n    to: '0x...',\n    from: '0x...',\n    value: '0x...',\n    // And so on...\n  },\n  (error, result) => {\n    if (error) {\n      return console.error(error);\n    }\n    // Handle the result\n    console.log(result);\n  }\n);\n\n// window.ethereum\ntry {\n  const transactionHash = await ethereum.request({\n    method: 'eth_sendTransaction',\n    params: [\n      {\n        to: '0x...',\n        from: '0x...',\n        value: '0x...',\n        // And so on...\n      },\n    ],\n  });\n  // Handle the result\n  console.log(transactionHash);\n} catch (error) {\n  console.error(error);\n}","metadata":{"source":"web3ToProvider"}}],["34",{"pageContent":"# Introduction","metadata":{"source":"mobile-getting-started"}}],["35",{"pageContent":"Why you and your users should use MetaMask Mobile\n\n- Onboard your users in seconds - whether they are already wallet users or completely new users, we guide them to get them started!\n- Bring your dapp to our large and rapidly growing userbase.\n- Your users can discover other use-cases of the decentralized web right in the MetaMask web3 browser.\n- Users can sign with their MetaMask wallet, whether they use your dapp on MetaMask browser or prefer using other primary browsers or native mobile app or desktop. [*works with dapps supporting Wallet Connect]\n- Buy crypto easily, with the best rates, and supported in a wide-range of countries.\n- Manage your cryptoassets - watch or trade tokens, collectibles\n- Send payments to your family and friends (gasless\\* and in normal transaction - whatever they prefer)\n- Request payment from a friend, an employer, etc.\n- We have lots of more exciting stuff coming up - stay tuned, this is just the beginning :wink:","metadata":{"source":"mobile-getting-started"}}],["36",{"pageContent":"Please visit [our homepage](https://metamask.io) to find out more about where to download the mobile app.","metadata":{"source":"mobile-getting-started"}}],["37",{"pageContent":"# Registering Tokens with Users\n\nWhen a user opens their MetaMask, they are shown a variety of assets, including tokens. By default, MetaMask auto-detects some major popular tokens and auto-displays them, but for most tokens, the user will need to add the token themselves.\n\nWhile this is possible using our UI with the `Add Token` button, that process can be cumbersome, and involves the user interacting with contract addresses, and is very error prone.\n\nYou can greatly improve the security and experience of users adding your token to their MetaMask by taking advantage of the `wallet_watchAsset` API as defined in [EIP-747](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-747.md).\n\n## Code-free Example\n\nHere are a couple live web applications that let you enter your token details, and then share them with a simple web link:\n\n- [Watch Token](https://vittominacori.github.io/watch-token/create/)\n- [Add Token App](https://metamask.github.io/Add-Token/#edit)","metadata":{"source":"registering-your-token"}}],["38",{"pageContent":"Example\n\nIf you'd like to integrate suggesting a token into your own web app, you can follow this code snippet to implement it:\n\n```javascript\nconst tokenAddress = '0xd00981105e61274c8a5cd5a88fe7e037d935b513';\nconst tokenSymbol = 'TUT';\nconst tokenDecimals = 18;\nconst tokenImage = 'http://placekitten.com/200/300';\n\ntry {\n  // wasAdded is a boolean. Like any RPC method, an error may be thrown.\n  const wasAdded = await ethereum.request({\n    method: 'wallet_watchAsset',\n    params: {\n      type: 'ERC20', // Initially only supports ERC20, but eventually more!\n      options: {\n        address: tokenAddress, // The address that the token is at.\n        symbol: tokenSymbol, // A ticker symbol or shorthand, up to 5 chars.\n        decimals: tokenDecimals, // The number of decimals in the token\n        image: tokenImage, // A string url of the token logo\n      },\n    },\n  });","metadata":{"source":"registering-your-token"}}],["39",{"pageContent":"if (wasAdded) {\n    console.log('Thanks for your interest!');\n  } else {\n    console.log('Your loss!');\n  }\n} catch (error) {\n  console.log(error);\n}\n```","metadata":{"source":"registering-your-token"}}],["40",{"pageContent":"# Permissions\n\n::: tip Developer Preview Software\nSnaps is pre-release software. To try Snaps, install [MetaMask Flask](https://metamask.io/flask).\n:::\n\n::: tip Feature Requests\nDo you have feature requests? Other ideas? We'd love to hear about them! [Click here](https://github.com/MetaMask/snaps-monorepo/discussions) to join the discussion.\n:::\n\nTo access certain powerful JavaScript globals or JSON-RPC methods, your snap will need to ask the user for permission. Snaps follow the [EIP-2255 wallet permissions specification](https://eips.ethereum.org/EIPS/eip-2255), and your snap's required permissions must be specified in the `initialPermissions` field of your [`snap.manifest.json` file](./snaps-development-guide.md#the-snap-manifest).\n\n## Table of Contents\n\n[[toc]]","metadata":{"source":"snaps-permissions"}}],["41",{"pageContent":"Endowments\n\n### `endowment:rpc`\n\nFor snaps that need to handle arbitrary JSON-RPC requests, the `rpc` endowment is required. This permission grants a snap access to JSON-RPC requests sent to the snap, using the `onRpcRequest` method. See [Exports](./snaps-exports.html#onrpcrequest) for more information.\n\nThis permission requires an object with a `snaps` or `dapps` property (or both), to signal if the snap can receive JSON-RPC requests from other snaps, or dapps, respectively. Both values default to `false`.\n\n```json\n{\n  \"initialPermissions\": {\n    \"endowment:rpc\": {\n      \"dapps\": true,\n      \"snaps\": false\n    }\n  }\n}\n```\n\n### `endowment:long-running`\n\nFor snaps that are computationally heavy and can't finish execution within [the snap lifecycle requirements](./snaps-development-guide.md#the-snap-lifecycle), the snap can request the `endowment:long-running` permission.\nThis permission will effectively allow snaps to run indefinitely while processing RPC requests.","metadata":{"source":"snaps-permissions"}}],["42",{"pageContent":"`endowment:network-access`\n\nFor snaps that need to access the internet, the snap can request the `endowment:network-access` permission. This permission will expose the global networking APIs `fetch` and `WebSocket` to the snap execution environment. Without this permission, these globals will not be available.\n\n::: warning Avoid XMLHttpRequest\n`XMLHttpRequest` is never available in snaps, and you should replace it with `fetch`. If your dependencies are using `XMLHttpRequest`, you can learn how to patch it away [here](./snaps-patching-dependencies.md#patching-the-use-of-xmlhttprequest).\n:::","metadata":{"source":"snaps-permissions"}}],["43",{"pageContent":"`endowment:transaction-insight`\n\nFor snaps that provide transaction insights, the snap can request the `endowment:transaction-insight` permission. This permission grants a snap read-only access to raw transaction payloads, before they are accepted for signing by the user, by exporting the `onTransaction` method. See [Exports](./snaps-exports.html#ontransaction) for more information.\n\nThis permission requires an object with an `allowTransactionOrigin` property to signal if the snap should pass the `transactionOrigin` property as part of the `onTransaction` parameters. This property represents the transaction initiator origin. Default to `false`.\n\n```json\n{\n  \"endowment:transaction-insight\": {\n    \"allowTransactionOrigin\": true\n  }\n}\n```","metadata":{"source":"snaps-permissions"}}],["44",{"pageContent":"`endowment:cronjob`\n\nFor snaps that wants to run periodic actions for the user, the snap can request the `endowment:cronjob` permission. This permission allows a snap to specify periodic requests that will trigger the exported `onCronjob` method. see [Exports](./snaps-exports.html#oncronjob).\n\nCronjobs are specified as follows:\n\n```json\n{\n  \"initialPermissions\": {\n    \"endowment:cronjob\": {\n      \"jobs\": [\n        {\n          \"expression\": {\n            \"minute\": \"*\",\n            \"hour\": \"*\",\n            \"dayOfMonth\": \"*\",\n            \"month\": \"*\",\n            \"dayOfWeek\": \"*\"\n          },\n          \"request\": {\n            \"method\": \"exampleMethodOne\",\n            \"params\": {\n              \"param1\": \"foo\"\n            }\n          }\n        },\n        {\n          \"expression\": \"* * * * *\",\n          \"request\": {\n            \"method\": \"exampleMethodTwo\",\n            \"params\": {\n              \"param1\": \"bar\"\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```","metadata":{"source":"snaps-permissions"}}],["45",{"pageContent":"`endowment:ethereum-provider`\n\nFor snaps that wish to communicate with a node via MetaMask, the snap can request the `endowment:ethereum-provider` permission. This permission will expose the global API `ethereum` to the snap execution environment. Without this permission, this global will not be available. This global is a EIP-1193 provider.","metadata":{"source":"snaps-permissions"}}],["46",{"pageContent":"RPC Permissions\n\nTo use any restricted RPC method, a snap will need to request permissions to access that method. For a list of available RPC methods and thus valid RPC permissions see [JSON-RPC API](./snaps-rpc-api.html#restricted-methods).","metadata":{"source":"snaps-permissions"}}],["47",{"pageContent":"# Introduction\n\nWelcome to MetaMask’s Developer Documentation. MetaMask is the trailblazing tool enabling user interactions and experience on Web3. It is currently available as a browser extension and as a mobile app on both Android and iOS devices. The purpose of this documentation is to illustrate how to build a dapp with MetaMask.\n\n- You can find the latest version of MetaMask on our [official website](https://metamask.io/).\n- For help using MetaMask, visit our [User Support Site](https://metamask.zendesk.com/).\n- For up to the minute news, follow our [Twitter](https://twitter.com/MetaMask) or [Medium](https://medium.com/metamask) pages.\n- To learn how to contribute to the MetaMask project itself, visit our [Internal Docs](https://github.com/MetaMask/metamask-extension/tree/develop/docs).","metadata":{"source":"README"}}],["48",{"pageContent":"::: tip Recent Breaking Provider Changes\nIf you are an Ethereum application developer and are looking for information about our January 2021 provider API changes,\nplease see our [Migration Guide](./provider-migration.html) for more details.\n:::","metadata":{"source":"README"}}],["49",{"pageContent":"Why MetaMask\n\nMetaMask was created to meet the needs of secure and usable Ethereum-based web sites. In particular, it handles account management and connecting the user to the blockchain.\n\n- [Get started here](./getting-started.md)\n- [Learn more about our JavaScript Provider API](./ethereum-provider.md)\n- [Learn more about our RPC API](./rpc-api.md)","metadata":{"source":"README"}}],["50",{"pageContent":"Account Management\n\nMetaMask allows users to manage accounts and their keys in a variety of ways, including hardware wallets, while isolating them from the site context. This is a great security improvement over storing the user keys on a single central server, or even in local storage, which can allow for [mass account thefts](https://www.ccn.com/cryptocurrency-exchange-etherdelta-hacked-in-dns-hijacking-scheme/).","metadata":{"source":"README"}}],["51",{"pageContent":"This security feature also comes with developer convenience: For developers, you simply interact with the globally available `ethereum` API that identifies the users of web3-compatible browsers (like MetaMask users), and whenever you request a transaction signature (like `eth_sendTransaction`, `eth_signTypedData`, or others), MetaMask will prompt the user in as comprehensible a way as possible. This keeps users informed, and leaves attackers only the option of trying to phish individual users, rather than performing mass hacks (although [DNS hacks can still be used for phishing en masse](https://medium.com/metamask/new-phishing-strategy-becoming-common-1b1123837168)).","metadata":{"source":"README"}}],["52",{"pageContent":"Blockchain Connection\n\nMetaMask comes pre-loaded with fast connections to the Ethereum blockchain and several test networks via our friends at [Infura](https://infura.io/). This allows you to get started without synchronizing a full node, while still providing the option to upgrade your security and use the blockchain provider of your choice.\n\nToday, MetaMask is compatible with any blockchain that exposes an [Ethereum-compatible JSON RPC API](https://eth.wiki/json-rpc/API), including custom and private blockchains. For development, we recommend running a test blockchain like [Ganache](https://www.trufflesuite.com/ganache).\n\nWe are aware that there are constantly new private blockchains being created. If you are interested in integrating MetaMask with your own custom network, [we have an API that has already enabled a number of networks to do the same.](https://medium.com/metamask/connect-users-to-layer-2-networks-with-the-metamask-custom-networks-api-d0873fac51e5).","metadata":{"source":"README"}}],["53",{"pageContent":"New Dapp Developers\n\n- [Learning Solidity](https://karl.tech/learning-solidity-part-1-deploy-a-contract/) by karl Floersch\n- [CryptoZombies](https://cryptozombies.io/)\n- [Getting Started with Truffle](https://www.trufflesuite.com/docs/truffle/quickstart)\n- [Keeping up with Blockchain Development (from ConsenSys Academy)](https://github.com/ConsenSys-Academy/Blockchain-Developer-Bootcamp/blob/main/docs/S00-intro/L6-keeping-up/index.md)\n- Launch into the Web3 space with [ConsenSys Academy's Blockchain Developer Bootcamp](https://consensys.net/academy/bootcamp/)\n- Explore everything ConsenSys at the [ConsenSys Developer Portal](https://consensys.net/developers/)","metadata":{"source":"README"}}],["54",{"pageContent":"# Options\n\nThe MetaMask JS SDK takes several options, for example:\n\n```javascript\nconst options = {\n  injectProvider: false,\n  communicationLayerPreference: 'webrtc',\n};\n\nconst MMSDK = new MetaMaskSDK(options);","metadata":{"source":"metamask-sdk-js-options"}}],["55",{"pageContent":"Check the full list of options:","metadata":{"source":"metamask-sdk-js-options"}}],["56",{"pageContent":"| Option name                    |                      Type                      | Default value | Description                                                                                                                                                                                                                                |\n| ------------------------------ | :--------------------------------------------: | :-----------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |","metadata":{"source":"metamask-sdk-js-options"}}],["57",{"pageContent":"| `dappMetadata`                 | `{name: \"My Dapp\", url: \"https://mydapp.com\"}` |  `undefined`  | dappMetadata is only required for non-web dapps (for example React Native and Unity)                                                                                                                                                       |\n| `injectProvider`               |                   `boolean`                    |    `true`     | Note: will not inject in NodeJS or React Native as the window object is unavailable.                                                                                                                                                       |","metadata":{"source":"metamask-sdk-js-options"}}],["58",{"pageContent":"| `forceInjectProvider`          |                   `boolean`                    |    `false`    | Forces injection even if another provider is already present on the window object.                                                                                                                                                         |\n| `forceDeleteProvider`          |                   `boolean`                    |    `false`    | Forces deletion of a provider that exists on a window.                                                                                                                                                                                     |","metadata":{"source":"metamask-sdk-js-options"}}],["59",{"pageContent":"| `checkInstallationImmediately` |                   `boolean`                    |    `false`    | The SDK checks if MetaMask is installed when a call to `eth_requestAccounts` is made. When `true`, it checks before any call is made.                                                                                                      |\n| `checkInstallationOnAllCalls`  |                   `boolean`                    |    `false`    | Normally checked when a call to `eth_requestAccounts` is made. When `true`, it checks on all calls.                                                                                                                                        |","metadata":{"source":"metamask-sdk-js-options"}}],["60",{"pageContent":"| `shouldShimWeb3`               |                   `boolean`                    |    `true`     | Set as `true` if `window.web3` should be shimmed for legacy compatibility purposes. [More info](/provider-migration.html#replacing-window-web3)                                                                                            |\n| `preferDesktop`                |                   `boolean`                    |    `false`    | For a web dapp running on a desktop browser without a MetaMask extension, the SDK gives the option to connect with a MetaMask Mobile wallet via a QR code. When `true`, the SDK guides the user to install the MetaMask extension instead. |","metadata":{"source":"metamask-sdk-js-options"}}],["61",{"pageContent":"| `openDeeplink`                 |        `(deeplinkUrl: string) => void`         |  `undefined`  | Platforms open deep links differently. e.g, web: `window.open` versus React Native: `Linking.open`. This function retrieves the deep link url and allows developers to customize how it opens.                                             |\n| `getUniversalLink`             |                 `() => string`                 |  `undefined`  | Get the universal link that is presented on the QR Code (web) and deeplinks (mobile). This makes it easier to enable users to connect with backend code.                                                                                   |","metadata":{"source":"metamask-sdk-js-options"}}],["62",{"pageContent":"| `communicationLayerPreference` |             `\"socket\" or \"webrtc\"`             |   `socket`    | Defines the communication library that the dapp and MetaMask wallet use to communicate with each other. Waku or another similar decentralized communication layer solution coming soon.                                                    |\n| `webRTCLib`                    |                  `WebRTC Lib`                  |  `undefined`  | Not installed on the SDK by default. Check the React Native section to see how to install it.                                                                                                                                              |","metadata":{"source":"metamask-sdk-js-options"}}],["63",{"pageContent":"| `WalletConnectInstance`        |              `WalletConnect Lib`               |  `undefined`  | Another way of connecting a dapp to MetaMask. Not installed by default. Check [here](https://docs.walletconnect.com/) on how to install it.                                                                                                |\n| `forceRestartWalletConnect`    |                   `boolean`                    |    `false`    | Set `forceRestartWalletConnect` to `true` to kill the previous WalletConnect session and start another one.                                                                                                                                |","metadata":{"source":"metamask-sdk-js-options"}}],["64",{"pageContent":"| `transports`                   |           `['websocket', 'polling']`           |  `undefined`  | Used to set the preference on socket.io transports to 'use'. Check the socket.io [documentation](https://socket.io/docs/v4/) for more details.                                                                                             |\n| `timer`                        |               `BackgroundTimer`                |  `undefined`  | Used by React Native apps to keep the app alive while in the background using `react-native-background-timer`                                                                                                                              |","metadata":{"source":"metamask-sdk-js-options"}}],["65",{"pageContent":"| `enableDebug`                  |                   `boolean`                    |    `true`     | Enebles/disables the sending of debugging information to the `socket.io` server. It defaults to `true` for beta version of the SDK. It'll default to `false` on production ones.                                                           |","metadata":{"source":"metamask-sdk-js-options"}}],["66",{"pageContent":":::tip\nIf your project is a web app and `injectProvider` is `true`, then the `ethereum` object should be available in `window.ethereum`.\n:::","metadata":{"source":"metamask-sdk-js-options"}}],["67",{"pageContent":"# Other web frameworks\n\nIf you are developing a web application that users can access via a desktop or mobile browser, you can import the MetaMask SDK and it will guide users to easily connect with MetaMask.\n\nIf the user is on a desktop browser and doesn't have the MetaMask extension installed, a popup will appear that will prompt users to either install MetaMask extension or to connect with MetaMask Mobile via a QR code.\n\nIf on a mobile browser, the SDK will automatically deeplink into MetaMask Mobile (or prompt users to install if they don't already have it) and once users accept the connection, they will be automatically redirected back to your web app. This will happen for all actions that need user approval.\n\nIf you are using React or similar frameworks you can use the SDK via import-style:\n\n```javascript\nimport MetaMaskSDK from '@metamask/sdk';\n\nconst MMSDK = new MetaMaskSDK(options);\n\nconst ethereum = MMSDK.getProvider(); // You can also access via window.ethereum","metadata":{"source":"metamask-sdk-other-frameworks"}}],["68",{"pageContent":"```javascript\nimport MetaMaskSDK from '@metamask/sdk';\n\nconst MMSDK = new MetaMaskSDK(options);\n\nconst ethereum = MMSDK.getProvider(); // You can also access via window.ethereum\n\nethereum.request({ method: 'eth_requestAccounts', params: [] });","metadata":{"source":"metamask-sdk-other-frameworks"}}],["69",{"pageContent":"For a list of possible `options` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\nThat's it!\n\n:::tip\nYou should always call `eth_requestAccounts` first, that is what prompts the installation/connection popup to appear!\n\nFor other possible methods, check [the Ethereum Provider API](/ethereum-provider.html)\n:::","metadata":{"source":"metamask-sdk-other-frameworks"}}],["70",{"pageContent":"Recordings\n\n- [Destkop web browser](https://recordit.co/g9u0X2S60Z)\n- [Mobile web browser](https://recordit.co/2qy9lCVHWC)\n\n### Examples\n\n- [Hosted Test Dapp with SDK installed](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/test-dapp/)\n- [React Project](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/downloads/create-react-app_v0.1.0.zip)\n\n#### Install the example: `yarn`\n\n#### Run the example: `yarn start`","metadata":{"source":"metamask-sdk-other-frameworks"}}],["71",{"pageContent":"# Pure javascript\n\nIf you are developing a web application that users can access via a desktop or mobile browser, you can import the MetaMask SDK and it will guide users to easily connect with MetaMask.\n\nIf the user is on a desktop browser and doesn't have the MetaMask extension installed, a popup will appear that will prompt users to either install MetaMask extension or to connect with MetaMask Mobile via a QR code.\n\nIf on a mobile browser, the SDK will automatically deeplink into MetaMask Mobile (or prompt users to install if they don't already have it) and once users accept the connection, they will be automatically redirected back to your web app. This will happen for all actions that need user approval.\n\nIf your project just uses pure javascript, you can import the SDK by putting a script on the head section of your website:\n\n```javascript\n<head>\n...\n\n<script src=\"https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/cdn/metamask-sdk.js\"></script>\n\n<script>\n\n    const MMSDK = new MetaMaskSDK()","metadata":{"source":"metamask-sdk-pure-javascript"}}],["72",{"pageContent":"```javascript\n<head>\n...\n\n<script src=\"https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/cdn/metamask-sdk.js\"></script>\n\n<script>\n\n    const MMSDK = new MetaMaskSDK()\n\n    const ethereum = MMSDK.getProvider() // You can also access via window.ethereum\n\n    ethereum.request({method: 'eth_requestAccounts'})\n\n</script>\n\n...\n</head>","metadata":{"source":"metamask-sdk-pure-javascript"}}],["73",{"pageContent":"For a list of possible `options` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\n:::tip\nYou should always call `eth_requestAccounts` first, that is what prompts the installation/connection popup to appear!\n\nFor other possible methods, check [the Ethereum Provider API](/ethereum-provider.html)\n:::\n\nThat's it!","metadata":{"source":"metamask-sdk-pure-javascript"}}],["74",{"pageContent":"Recordings\n\n- [Destkop web browser](https://recordit.co/g9u0X2S60Z)\n- [Mobile web browser](https://recordit.co/2qy9lCVHWC)\n\n### Examples\n\n- [Hosted Test Dapp with SDK installed](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/test-dapp/)\n- [React Project](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/downloads/create-react-app_v0.1.0.zip)\n\n#### Install the example: `yarn`\n\n#### Run the example: `yarn start`","metadata":{"source":"metamask-sdk-pure-javascript"}}],["75",{"pageContent":"# React Native\n\nYou can import the MetaMask SDK into your React Native app to enable your users to easily connect with their MetaMask Mobile wallet. The SDK will automatically deeplink your users into their MetaMask Mobile wallet and once users accept the connection, they will be redirected back automatically to your app. This will happen for all actions that need user approval.","metadata":{"source":"metamask-sdk-react-native"}}],["76",{"pageContent":"Installation specifics\n\n#### 1. Install [rn-nodeify](https://github.com/tradle/rn-nodeify)\n\n```bash\nyarn add --dev rn-nodeify\nor\nnpm i --dev rn-nodeify\n```\n\n#### 2. Install rn-nodeify libraries\n\n```bash\nyarn add react-native-crypto\nyarn add react-native-randombytes\nyarn add crypto\nyarn add process\nyarn add stream\nyarn add events\n```\n\n#### 3. Insert rn-nodeify post install script into `package.json` -> `\"scripts\"`\n\n```bash\n\"postinstall\": \"rn-nodeify --install 'crypto,process,stream,events' --hack\"\n```\n\n#### 4. Import rn-nodeify shim.js\n\nrn-nodeify will create a shim.js file in your project root directory. You should import it in the root file of your application.\n\n```bash\nimport './shim'\n```\n\n#### 5. Install react-native-background-timer\n\n```bash\nyarn add react-native-background-timer\n\ncd ios && pod install && cd ..\n```\n\n#### 6. Install the MetaMask SDK\n\n```bash\nyarn add @metamask/sdk\n```\n\n#### 7. Run postinstall\n\nMake sure you run the postinstall script after everything is installed\n\n```bash\nyarn postinstall\n```","metadata":{"source":"metamask-sdk-react-native"}}],["77",{"pageContent":"6. Install the MetaMask SDK\n\n```bash\nyarn add @metamask/sdk\n```\n\n#### 7. Run postinstall\n\nMake sure you run the postinstall script after everything is installed\n\n```bash\nyarn postinstall\n```\n\n#### 8. Install pods\n\nFinally install the necessary pods that came with the libraries\n\n```bash\ncd ios && pod install && cd ..\n```\n\nNow you should be able to use the MetaMask SDK!","metadata":{"source":"metamask-sdk-react-native"}}],["78",{"pageContent":"Use the SDK\n\n```javascript\nimport MetaMaskSDK from '@metamask/sdk';\nimport { Linking } from 'react-native';\nimport BackgroundTimer from 'react-native-background-timer';\n\nconst MMSDK = new MetaMaskSDK({\n  openDeeplink: (link) => {\n    Linking.openURL(link); // Use React Native Linking method or your favourite way of opening deeplinks\n  },\n  timer: BackgroundTimer, // To keep the app alive once it goes to background\n  dappMetadata: {\n    name: 'My App', // The name of your application\n    url: 'https://myapp.com', // The url of your website\n  },\n});\n\nconst ethereum = MMSDK.getProvider();\n\nconst accounts = await ethereum.request({ method: 'eth_requestAccounts' });","metadata":{"source":"metamask-sdk-react-native"}}],["79",{"pageContent":"For a list of possible `options` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\nIt's now possible to use [EthersJS](https://docs.ethers.io/v5/getting-started/) with your React Native app!\n\n```javascript\nconst provider = new ethers.providers.Web3Provider(ethereum);\n\n// Get the balance of an account (by address or ENS name, if supported by network)\nconst balance = await provider.getBalance(ethereum.selectedAddress);\n\n// Often you need to format the output to something more user-friendly,\n// such as in ether (instead of wei)\nconst balanceInETH = ethers.utils.formatEther(balance);\n// '0.182826475815887608'","metadata":{"source":"metamask-sdk-react-native"}}],["80",{"pageContent":":::tip\nYou should always call `eth_requestAccounts` first--that is what prompts the deeplinking into MetaMask Mobile for connection!\n\nFor other possible methods, check [the Ethereum Provider API](/ethereum-provider.html)\n:::\n\nThat's it!\n\nNOTE: We are working on creating a `metamask-react-native-sdk` package that will install all of this automatically which will make the installation much easier for React Native apps.","metadata":{"source":"metamask-sdk-react-native"}}],["81",{"pageContent":"Recordings\n\n- [React Native app](https://recordit.co/FClppLgWzT)\n\n### React Native examples:\n\n- [React Native example](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/downloads/reactNativeApp_v0.1.0.zip)\n\n#### Install the example: `yarn setup`\n\n#### Run the example: `yarn ios` or `yarn android`","metadata":{"source":"metamask-sdk-react-native"}}],["82",{"pageContent":"# React\n\nIf you are developing a web application that users can access via a desktop or mobile browser, you can import the MetaMask SDK and it will guide users to easily connect with MetaMask.\n\nIf the user is on a desktop browser and doesn't have the MetaMask extension installed, a popup will appear that will prompt users to either install MetaMask extension or to connect with MetaMask Mobile via a QR code.\n\nIf on a mobile browser, the SDK will automatically deeplink into MetaMask Mobile (or prompt users to install if they don't already have it) and once users accept the connection, they will be automatically redirected back to your web app. This will happen for all actions that need user approval.\n\n<!--\nThere are two ways of using the MetaMask SDK with React:\n\n- [Using the MetaMask Button and MetaMask Hooks for React (easiest)](#metamask-button-and-metamask-hooks-for-react)\n- [Using the MetaMask SDK directly](#using-the-metamask-sdk-directly)","metadata":{"source":"metamask-sdk-react"}}],["83",{"pageContent":"MetaMask Button and MetaMask Hooks for React\n\nThe easiest way of using the MetaMask SDK on a React web app is to import our React library that was built using great web3 tools from our friends at [wagmi](https://wagmi.sh) and [ethers](https://docs.ethers.io/):\n\n```javascript\nyarn add @metamask/sdk-react","metadata":{"source":"metamask-sdk-react"}}],["84",{"pageContent":"Then on the root of your React app import the MetaMask Provder and wrap the root of your application\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nimport { MetaMaskProvider } from '@metamask/sdk-react'; // Import the MetaMask Provider here\n\nimport { chain } from '@metamask/sdk-react';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nconst networks = [chain.mainnet, chain.polygon, chain.optimism]; // Make your app support any network you want\nconst sdkOptions = {\n  injectProvider: true,\n};\n\n// Make sure to wrap the root of your app with the MetaMaskProvider\nroot.render(\n  <React.StrictMode>\n    <MetaMaskProvider networks={[networks]} MetaMaskSDKOptions={sdkOptions}>\n      <App />\n    </MetaMaskProvider>\n  </React.StrictMode>\n);","metadata":{"source":"metamask-sdk-react"}}],["85",{"pageContent":"For a list of possible `MetaMaskSDKOptions` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\nAdd the MetaMask Button to the UI:\n\n```javascript\nimport { MetaMaskButton } from '@metamask/sdk-react';\n\n...\n\n<div>\n  <MetaMaskButton/>\n</div>\n```\n\nYou can also use any React Hooks from [Wagmi](https://wagmi.sh/docs/hooks/useAccount):\n\n```javascript\nimport { MetaMaskButton, useAccount, useSignMessage } from '@metamask/sdk-react';\n\n...\n\nconst { isConnected } = useAccount();\nconst {\n    data,\n    isError,\n    isLoading,\n    isSuccess,\n    signMessage,\n  } = useSignMessage({\n    message: 'gm wagmi frens',\n  });\n\n...\n\n<div>\n  <MetaMaskButton/>\n  {isConnected && (\n    <div>\n      <button disabled={isLoading} onClick={() => signMessage()}>\n        Click to sign\n      </button>\n      {isSuccess && <div>Signature: {data}</div>}\n      {isError && <div>Error signing message</div>}\n    </div>\n  )}\n</div>\n\n```","metadata":{"source":"metamask-sdk-react"}}],["86",{"pageContent":"Using the MetaMask SDK directly\n\nIf you want to use the MetaMask SDK directly you can do it via import-style.\n-->\n\n### 1. Install a MetaMask Mobile version compatible with the SDK\n\nIn order to test the MetaMask SDK, developers need access to a MetaMask Mobile build that is compatible with the SDK. Please install MetaMask Mobile v5.8.1 or above.\n\n### 2. Install the SDK\n\n```bash\nyarn add @metamask/sdk\nor\nnpm i @metamask/sdk\n```","metadata":{"source":"metamask-sdk-react"}}],["87",{"pageContent":"2. Install the SDK\n\n```bash\nyarn add @metamask/sdk\nor\nnpm i @metamask/sdk\n```\n\n### 3. Use the SDK\n\n```javascript\nimport MetaMaskSDK from '@metamask/sdk';\n\nconst MMSDK = new MetaMaskSDK(options);\n\nconst ethereum = MMSDK.getProvider(); // You can also access via window.ethereum\n\nethereum.request({ method: 'eth_requestAccounts', params: [] });\n```\n\nFor a list of possible `options` check [here](/metamask-sdk-js/metamask-sdk-js-options.html)\n\n:::tip\nYou should always call `eth_requestAccounts` first, that is what prompts the installation/connection popup to appear!\n\nFor other possible methods, check [the Ethereum Provider API](/ethereum-provider.html)\n:::\n\nThat's it!\n\n### Recordings\n\n- [Destkop web browser](https://recordit.co/g9u0X2S60Z)\n- [Mobile web browser](https://recordit.co/2qy9lCVHWC)","metadata":{"source":"metamask-sdk-react"}}],["88",{"pageContent":"Recordings\n\n- [Destkop web browser](https://recordit.co/g9u0X2S60Z)\n- [Mobile web browser](https://recordit.co/2qy9lCVHWC)\n\n### Examples\n\n- [Hosted Test Dapp with SDK installed](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/test-dapp-2/)\n- [React Project](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/downloads/create-react-app_v0.1.0.zip)\n\n#### Install the example: `yarn`\n\n#### Run the example: `yarn start`","metadata":{"source":"metamask-sdk-react"}}],["89",{"pageContent":"# Registering Your Contract's Method Names\n\nMetaMask uses the Parity on-chain registry of function signatures to display method names on the confirm screen.\nFor many common method names, like token methods, this allows MetaMask to successfully look up the method names by their [method signature](https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html).\nHowever, sometimes you're using a method that is not in that on-chain registry, and MetaMask will simply display `Contract Interaction` to the user.\n\nTo add your contract's function names to this registry so it shows in the MetaMask interface, follow the below steps.\n\n1. Go to the [Mainnet Parity signature registration contract on etherscan](https://etherscan.io/address/0x44691b39d1a75dc4e0a0346cbb15e310e6ed1e86#writeContract)\n\n2. Connect MetaMask\n\n3. Use etherscan's write contract feature to input the string value (without quotes or spaces) to the register function\n\n   For example:\n\n   `getOwners()`","metadata":{"source":"registering-function-names"}}],["90",{"pageContent":"2. Connect MetaMask\n\n3. Use etherscan's write contract feature to input the string value (without quotes or spaces) to the register function\n\n   For example:\n\n   `getOwners()`\n\n   `execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)`\n\n4. Click \"write\"\n\n5. Approve the transaction in MetaMask (you only pay gas)","metadata":{"source":"registering-function-names"}}],["91",{"pageContent":"Verify\n\n`ethers.utils.keccak256('getOwners()') => 0xa0e67e2bdc0a6d8a09ccd6c353c9df590807ad66ff5e6630c4f31a86dfa84821`\n\n- Take the first 10 characters: `0xa0e67e2b`\n- Input them into [this demo app](https://jennypollack.github.io/function_signature_registry/) that checks the on-chain registry\n  - Mainnet or Rinkeby only\n\n### Using remix.ethereum.org\n\n- Paste the contract code from [bokky's blog post](https://www.bokconsulting.com.au/blog/a-quick-look-at-paritys-signature-registry-contract/) into [remix](https://remix.ethereum.org).\n- Set the correct compiler version based on the contract.\n- Use remix's write functionality to add to the registry.\n- You can look at the FUNCTIONHASHES section on [remix](https://remix.ethereum.org) by loading the signature registry contract, press the \"details\" button on the compile tab.","metadata":{"source":"registering-function-names"}}],["92",{"pageContent":"Using `eth-method-registry`\n\n- You can also use the [signature registry](https://rinkeby.etherscan.io/address/0x0c0831fb1ec7442485fb41a033ba188389a990b4) deployed on Rinkeby\n  - [`eth-method-registry`](https://github.com/MetaMask/eth-method-registry) is used to lookup methods in MetaMask.\n  - Note that MetaMask reads from the Mainnet `eth-method-registry` endpoint, regardless of user's network.\n  - For more details, see [this StackExchange answer](https://ethereum.stackexchange.com/questions/59678/metamask-shows-unknown-function-when-calling-method-send-function).","metadata":{"source":"registering-function-names"}}],["93",{"pageContent":"# Onboarding Library\n\nAs an Ethereum enabled site developer, sending users offsite to install MetaMask presents challenges. Most notably, you must inform the user to return to your site and refresh their browser after the installation. Your site will detect the user's newly installed MetaMask extension only after that refresh. We at MetaMask care deeply about user experience, and we knew that this workflow needed to be improved.\n\nMetaMask now provides a [metamask-onboarding library](https://github.com/MetaMask/metamask-onboarding) designed to improve and simplify the onboarding experience. The new library exposes an API to initiate the onboarding process. In the process, it registers your site as the origin of the onboarding request. MetaMask will check for this origin after the user completes the onboarding flow. If it finds an origin, the final confirmation button of the MetaMask onboarding flow will indicate that the user will be redirected back to your site.","metadata":{"source":"onboarding-library"}}],["94",{"pageContent":"Getting Started\n\n1. Install @metamask/onboarding using npm or yarn.\n2. Import the Onboarding Library or include it in your page.\n\n```javascript\n// As an ES6 module\nimport MetaMaskOnboarding from '@metamask/onboarding';\n// Or as an ES5 module\nconst MetaMaskOnboarding = require('@metamask/onboarding');\n```\n\nIf you'd prefer you can instead include the prebuilt ES5 bundle that ships with the library:\n\n```html\n<script src=\"./metamask-onboarding.bundle.js\"></script>\n```\n\n3. Create a new instance of the Onboarding library\n\n```javascript\nconst onboarding = new MetaMaskOnboarding();\n```\n\n4. Start the onboarding process in response to a user event (e.g. a button click).\n\n```javascript\nonboarding.startOnboarding();\n```","metadata":{"source":"onboarding-library"}}],["95",{"pageContent":"Examples\n\n### Basic Usage\n\n```javascript\nconst onboarding = new MetaMaskOnboarding();\nonboarding.startOnboarding();\n```","metadata":{"source":"onboarding-library"}}],["96",{"pageContent":"Using React\n\n```jsx\nimport MetaMaskOnboarding from '@metamask/onboarding';\nimport React from 'react';\n\nconst ONBOARD_TEXT = 'Click here to install MetaMask!';\nconst CONNECT_TEXT = 'Connect';\nconst CONNECTED_TEXT = 'Connected';\n\nexport function OnboardingButton() {\n  const [buttonText, setButtonText] = React.useState(ONBOARD_TEXT);\n  const [isDisabled, setDisabled] = React.useState(false);\n  const [accounts, setAccounts] = React.useState([]);\n  const onboarding = React.useRef();\n\n  React.useEffect(() => {\n    if (!onboarding.current) {\n      onboarding.current = new MetaMaskOnboarding();\n    }\n  }, []);\n\n  React.useEffect(() => {\n    if (MetaMaskOnboarding.isMetaMaskInstalled()) {\n      if (accounts.length > 0) {\n        setButtonText(CONNECTED_TEXT);\n        setDisabled(true);\n        onboarding.current.stopOnboarding();\n      } else {\n        setButtonText(CONNECT_TEXT);\n        setDisabled(false);\n      }\n    }\n  }, [accounts]);","metadata":{"source":"onboarding-library"}}],["97",{"pageContent":"React.useEffect(() => {\n    function handleNewAccounts(newAccounts) {\n      setAccounts(newAccounts);\n    }\n    if (MetaMaskOnboarding.isMetaMaskInstalled()) {\n      window.ethereum\n        .request({ method: 'eth_requestAccounts' })\n        .then(handleNewAccounts);\n      window.ethereum.on('accountsChanged', handleNewAccounts);\n      return () => {\n        window.ethereum.removeListener('accountsChanged', handleNewAccounts);\n      };\n    }\n  }, []);\n\n  const onClick = () => {\n    if (MetaMaskOnboarding.isMetaMaskInstalled()) {\n      window.ethereum\n        .request({ method: 'eth_requestAccounts' })\n        .then((newAccounts) => setAccounts(newAccounts));\n    } else {\n      onboarding.current.startOnboarding();\n    }\n  };\n  return (\n    <button disabled={isDisabled} onClick={onClick}>\n      {buttonText}\n    </button>\n  );\n}\n```","metadata":{"source":"onboarding-library"}}],["98",{"pageContent":"Using TypeScript\n\nWe ship our TypeScript types with `@metamask/onboarding`. Modifying the above example to get type safety when using the onboarding library is simple:\n\n```jsx\n  -const onboarding = React.useRef();\n  +const onboarding = React.useRef<MetaMaskOnboarding>();\n```\n\nDoing this step will give you editor auto-completion for the methods exposed by the library, and helpful documentation.\n\n![Editor Highlighting](https://user-images.githubusercontent.com/4448075/85584481-ccc7ec00-b604-11ea-9b74-49c76ee0bf22.png)","metadata":{"source":"onboarding-library"}}],["99",{"pageContent":"Using Vanilla Javascript + HTML\n\n```html\n<!DOCTYPE html>\n<html lang=\"en-CA\">\n  <head>\n    <title>MetaMask Onboarding Example</title>\n    <meta charset=\"UTF-8\" />\n  </head>\n  <body>\n    <h1>Sample Dapp</h1>\n    <button id=\"onboard\">Loading...</button>\n    <script src=\"./metamask-onboarding.bundle.js\"></script>\n    <script>\n      window.addEventListener('DOMContentLoaded', () => {\n        const onboarding = new MetaMaskOnboarding();\n        const onboardButton = document.getElementById('onboard');\n        let accounts;","metadata":{"source":"onboarding-library"}}],["100",{"pageContent":"const updateButton = () => {\n          if (!MetaMaskOnboarding.isMetaMaskInstalled()) {\n            onboardButton.innerText = 'Click here to install MetaMask!';\n            onboardButton.onclick = () => {\n              onboardButton.innerText = 'Onboarding in progress';\n              onboardButton.disabled = true;\n              onboarding.startOnboarding();\n            };\n          } else if (accounts && accounts.length > 0) {\n            onboardButton.innerText = 'Connected';\n            onboardButton.disabled = true;\n            onboarding.stopOnboarding();\n          } else {\n            onboardButton.innerText = 'Connect';\n            onboardButton.onclick = async () => {\n              await window.ethereum.request({\n                method: 'eth_requestAccounts',\n              });\n            };\n          }\n        };","metadata":{"source":"onboarding-library"}}],["101",{"pageContent":"updateButton();\n        if (MetaMaskOnboarding.isMetaMaskInstalled()) {\n          window.ethereum.on('accountsChanged', (newAccounts) => {\n            accounts = newAccounts;\n            updateButton();\n          });\n        }\n      });\n    </script>\n  </body>\n</html>\n```","metadata":{"source":"onboarding-library"}}],["102",{"pageContent":"Onboarding Diagram\n\nHere is a diagram of the interactions between the onboarding library, the forwarder, and the extension:\n\n![Onboarding Library Diagram](https://user-images.githubusercontent.com/2459287/67541693-439c9600-f6c0-11e9-93f8-112a8941384a.png)","metadata":{"source":"onboarding-library"}}],["103",{"pageContent":"# Sending Transactions\n\nTransactions are a formal action on a blockchain. They are always initiated in MetaMask with a call to the `eth_sendTransaction` method. They can involve a simple sending of ether, may result in sending tokens, creating a new smart contract, or changing state on the blockchain in any number of ways. They are always initiated by a signature from an _external account_, or a simple key pair.\n\nIn MetaMask, using the `ethereum.request` method directly, sending a transaction will involve composing an options object like this:","metadata":{"source":"sending-transactions"}}],["104",{"pageContent":"In MetaMask, using the `ethereum.request` method directly, sending a transaction will involve composing an options object like this:\n\n```javascript\nconst transactionParameters = {\n  nonce: '0x00', // ignored by MetaMask\n  gasPrice: '0x09184e72a000', // customizable by user during MetaMask confirmation.\n  gas: '0x2710', // customizable by user during MetaMask confirmation.\n  to: '0x0000000000000000000000000000000000000000', // Required except during contract publications.\n  from: ethereum.selectedAddress, // must match user's active address.\n  value: '0x00', // Only required to send ether to the recipient from the initiating external account.\n  data:\n    '0x7f7465737432000000000000000000000000000000000000000000000000000000600057', // Optional, but used for defining smart contract creation and interaction.\n  chainId: '0x3', // Used to prevent transaction reuse across blockchains. Auto-filled by MetaMask.\n};","metadata":{"source":"sending-transactions"}}],["105",{"pageContent":"// txHash is a hex string\n// As with any RPC call, it may throw an error\nconst txHash = await ethereum.request({\n  method: 'eth_sendTransaction',\n  params: [transactionParameters],\n});\n```","metadata":{"source":"sending-transactions"}}],["106",{"pageContent":"Example\n\n<SendTransaction />\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab HTML\n\n```html\n<button class=\"enableEthereumButton btn\">Enable Ethereum</button>\n<button class=\"sendEthButton btn\">Send Eth</button>","metadata":{"source":"sending-transactions"}}],["107",{"pageContent":":::\n\n::: tab JavaScript\n\n```javascript\nconst ethereumButton = document.querySelector('.enableEthereumButton');\nconst sendEthButton = document.querySelector('.sendEthButton');\n\nlet accounts = [];\n\n//Sending Ethereum to an address\nsendEthButton.addEventListener('click', () => {\n  ethereum\n    .request({\n      method: 'eth_sendTransaction',\n      params: [\n        {\n          from: accounts[0],\n          to: '0x2f318C334780961FB129D2a6c30D0763d9a5C970',\n          value: '0x29a2241af62c0000',\n          gasPrice: '0x09184e72a000',\n          gas: '0x2710',\n        },\n      ],\n    })\n    .then((txHash) => console.log(txHash))\n    .catch((error) => console.error(error));\n});\n\nethereumButton.addEventListener('click', () => {\n  getAccount();\n});\n\nasync function getAccount() {\n  accounts = await ethereum.request({ method: 'eth_requestAccounts' });\n}\n```\n\n:::\n\n::::","metadata":{"source":"sending-transactions"}}],["108",{"pageContent":"Transaction Parameters\n\nMany transaction parameters are handled for you by MetaMask, but it's good to know what all the parameters do.","metadata":{"source":"sending-transactions"}}],["109",{"pageContent":"Nonce [ignored]\n\nThis field is ignored by MetaMask.\n\nIn Ethereum every transaction has a nonce. This is so that each transaction can only be processed by the blockchain once. Additionally, to be a valid transaction, the nonce must either be `0`, or a transaction with the previous number must have already been processed.\n\nThat means that transactions are always processed in order for a given account, and so incrementing nonces is a very sensitive matter that is easy to mess up, especially when a user is interacting with multiple applications with pending transactions using the same account, potentially across multiple devices.\n\nFor these reasons, MetaMask currently does not provide application developers any way to customize the nonce of transactions it suggests. Instead, MetaMask [assists the user in managing their transaction queue themselves](https://metamask.zendesk.com/hc/en-us/articles/360015489251).","metadata":{"source":"sending-transactions"}}],["110",{"pageContent":"Gas Price [optional]\n\nOptional parameter - best used on private blockchains.\n\nIn Ethereum, every transaction specifies a price for the gas that it will consume. To maximize their profit, block producers will pick pending transactions with higher gas prices first when creating the next block. This means that a high gas price will usually cause your transaction to be processed faster, at the cost of greater transaction fees. Note that this may not be true for e.g. Layer 2 networks, which may have a constant gas price or no gas price at all.\n\nIn other words, while you can ignore this parameter on MetaMask's default networks, you may want to include it in situations where your application knows more about the target network than we do. On our default networks, MetaMask allows users to choose between \"slow,\" \"medium,\" and \"fast\" options for their gas price. To learn how to use advanced gas controls [visit here](https://metamask.zendesk.com/hc/en-us/articles/360022895972).","metadata":{"source":"sending-transactions"}}],["111",{"pageContent":"Gas Limit [optional]\n\nOptional parameter. Rarely useful to Dapp developers.\n\nGas limit is a highly optional parameter, and we automatically calculate a reasonable price for it. You will probably know that your smart contract benefits from a custom gas limit if it ever does for some reason.\n\n### To [semi-optional]\n\nA hex-encoded Ethereum address. Required for transactions with a recipient (all transactions except for contract creation).\n\nContract creation occurs when there is no `to` value but there is a `data` value.","metadata":{"source":"sending-transactions"}}],["112",{"pageContent":"Value [optional]\n\nHex-encoded value of the network's native currency to send. On the Main Ethereum network, this is [ether](https://www.ethereum.org/eth), which is denominated in _wei_, which is `1e-18` ether.\n\nPlease note that these numbers often used in Ethereum are far higher precision than native JavaScript numbers, and can cause unpredictable behavior if not anticipated. For this reason, we highly recommend using [BN.js](https://github.com/indutny/bn.js/) when manipulating values intended for the blockchain.\n\n### Data [semi-optional]\n\nRequired for smart contract creation.\n\nThis field is also used for specifying contract methods and their parameters. You can learn more about how that data is encoded on [the solidity ABI spec](https://solidity.readthedocs.io/en/develop/abi-spec.html).","metadata":{"source":"sending-transactions"}}],["113",{"pageContent":"Chain ID [currently ignored]\n\nChain ID is currently derived by the user's current selected network at `ethereum.networkVersion`. In the future we will probably allow a way to connect to multiple networks at once, at which point this parameter will become important, so it may be useful to be in the habit of including now.","metadata":{"source":"sending-transactions"}}],["114",{"pageContent":"# Getting Started\n\nTo develop for MetaMask, install MetaMask in the browser of your choice on your development machine. [Download here](https://metamask.io/).\n\n::: warning A quick note...\nThis guide assumes intermediate knowledge of HTML, CSS, and JavaScript.\n:::\n\nOnce MetaMask is installed and running (make sure you back up your Secret Recovery Phrase), you should find that new browser tabs have a `window.ethereum` object available in the developer console.\nThis is how your website will interact with MetaMask.\n\nYou can review the full API for that object [here](./ethereum-provider.html).\nNote that **over the course of 2020**, we introduced significant changes to this API, and we recommend that you refer to its documentation.","metadata":{"source":"getting-started"}}],["115",{"pageContent":"Basic Considerations\n\n### Web3 Browser Detection\n\nTo verify if the browser is running MetaMask, copy and paste the code snippet below in the developer console of your web browser:\n\n```javascript\nif (typeof window.ethereum !== 'undefined') {\n  console.log('MetaMask is installed!');\n}\n```\n\nYou can review the full API for the `window.ethereum` object [here](./ethereum-provider.html).","metadata":{"source":"getting-started"}}],["116",{"pageContent":"Running a Test Network\n\nIn the top right menu of MetaMask, select the network that you are currently connected to. Among several popular defaults, you'll find `Custom RPC` and `Localhost 8545`. These are both useful for connecting to a test blockchain, like [ganache](https://www.trufflesuite.com/ganache). You can quickly install and start Ganache if you have `npm` installed with `npm i -g ganache-cli && ganache-cli`.\n\nGanache has some great features for starting your application with different states. If your application starts with the `-m` flag, you can feed it the same seed phrase you have in your MetaMask, and the test network will give each of your first 10 accounts 100 test ether, which makes it easier to start work.","metadata":{"source":"getting-started"}}],["117",{"pageContent":"Since your seed phrase has the power to control all your accounts, it is probably worth keeping at least one seed phrase for development, separate from any that you use for storing real value. One easy way to manage multiple seed phrases with MetaMask is with multiple browser profiles, each of which can have its own clean extension installations.","metadata":{"source":"getting-started"}}],["118",{"pageContent":"Resetting Your Local Nonce Calculation\n\nIf you're running a test blockchain and restart it, you can accidentally confuse MetaMask because it calculates the next [nonce](./sending-transactions.html#nonce-ignored)\nbased on both the network state _and_ the known sent transactions.\n\nTo clear MetaMask's transaction queue, and effectively reset its nonce calculation, you can use the `Reset Account` button in `Settings` (available in the top-right identicon menu).","metadata":{"source":"getting-started"}}],["119",{"pageContent":"Detecting MetaMask\n\nIf you want to differentiate MetaMask from other Ethereum-compatible browsers, you can detect MetaMask using `ethereum.isMetaMask`.\n\n### User State\n\nCurrently there are a few stateful things to consider when interacting with this API:\n\n- What is the current network?\n- What is the current account?\n\nBoth of these are available synchronously as `ethereum.networkVersion` and `ethereum.selectedAddress`.\nYou can listen for changes using events too, see ([the API reference](./ethereum-provider.html)).","metadata":{"source":"getting-started"}}],["120",{"pageContent":"Connecting to MetaMask\n\n\"Connecting\" or \"logging in\" to MetaMask effectively means \"to access the user's Ethereum account(s)\".\n\nYou should **only** initiate a connection request in response to direct user action, such as clicking a button.\nYou should **always** disable the \"connect\" button while the connection request is pending.\nYou should **never** initiate a connection request on page load.\n\nWe recommend that you provide a button to allow the user to connect MetaMask to your dapp.\nClicking this button should call the following method:\n\n```javascript\nethereum.request({ method: 'eth_requestAccounts' });\n```\n\n**Example:**\n\n<EthConnectButton />\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab HTML\n\n```html\n<button class=\"enableEthereumButton\">Enable Ethereum</button>","metadata":{"source":"getting-started"}}],["121",{"pageContent":"**Example:**\n\n<EthConnectButton />\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab HTML\n\n```html\n<button class=\"enableEthereumButton\">Enable Ethereum</button>\n```\n\n:::\n\n::: tab JavaScript\n\n```javascript\nconst ethereumButton = document.querySelector('.enableEthereumButton');\n\nethereumButton.addEventListener('click', () => {\n  //Will Start the metamask extension\n  ethereum.request({ method: 'eth_requestAccounts' });\n});","metadata":{"source":"getting-started"}}],["122",{"pageContent":":::\n\n::::\n\nThis promise-returning function resolves with an array of hex-prefixed Ethereum addresses, which can be used as general account references when sending transactions.\n\nOver time, this method is intended to grow to include various additional parameters to help your site request everything it needs from the user during setup.\n\nSince it returns a promise, if you're in an `async` function, you may log in like this:\n\n```javascript\nconst accounts = await ethereum.request({ method: 'eth_requestAccounts' });\nconst account = accounts[0];\n// We currently only ever provide a single account,\n// but the array gives us some room to grow.\n```\n\n**Example:**\n\n<EthAsyncConnectButton />\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab HTML\n\n```html\n<button class=\"enableEthereumButton\">Enable Ethereum</button>\n<h2>Account: <span class=\"showAccount\"></span></h2>","metadata":{"source":"getting-started"}}],["123",{"pageContent":":::\n\n::: tab JavaScript\n\n```javascript\nconst ethereumButton = document.querySelector('.enableEthereumButton');\nconst showAccount = document.querySelector('.showAccount');\n\nethereumButton.addEventListener('click', () => {\n  getAccount();\n});\n\nasync function getAccount() {\n  const accounts = await ethereum.request({ method: 'eth_requestAccounts' });\n  const account = accounts[0];\n  showAccount.innerHTML = account;\n}\n```\n\n:::\n\n::::","metadata":{"source":"getting-started"}}],["124",{"pageContent":"Choosing a Convenience Library\n\nConvenience libraries exist for a variety of reasons.\n\nSome of them simplify the creation of specific user interface elements, some entirely manage the user account onboarding, and others give you a variety of methods of interacting with smart contracts, for a variety of API preferences, from promises, to callbacks, to strong types, and so on.\n\nThe provider API itself is very simple, and wraps\n[Ethereum JSON-RPC](https://eth.wiki/json-rpc/API#json-rpc-methods)\nformatted messages, which is why developers usually use a convenience library for interacting\nwith the provider, like [ethers](https://www.npmjs.com/package/ethers), [web3.js](https://www.npmjs.com/package/web3),\n[truffle](https://www.trufflesuite.com/), [Embark](https://framework.embarklabs.io/), or others. From those tools,\nyou can generally find sufficient documentation to interact with the provider, without reading this lower-level API.","metadata":{"source":"getting-started"}}],["125",{"pageContent":"# Concepts","metadata":{"source":"metamask-sdk-concepts"}}],["126",{"pageContent":"Connections","metadata":{"source":"metamask-sdk-concepts"}}],["127",{"pageContent":"Lifecycle\n\nWhen connecting with MetaMask Mobile wallet, it's important to understand when connections get paused, resumed and cleared.\n\n#### Paused:\n\nConnections get paused after the MetaMask Mobile app is in background (minimized) for 20 seconds. This is to accomodate OS restrictions and it means that all traffic into MetaMask Mobile gets paused and the SDK won't produce any response unless the MetaMask Mobile app is opened again. The SDK automatically deeplinks into MetaMask Mobile so connections should be resumed automatically.\nIf MetaMask Mobile is in pause mode and the user completely closes the app, the connection will be maintained in paused mode until it's opened again.\n\nFor this reason, polling data from the wallet may not work for long periods of time.","metadata":{"source":"metamask-sdk-concepts"}}],["128",{"pageContent":"Cleared:\n\nConnections get cleared if the dapp is closed or refreshed (in the case of a browser) as we don't persist connections on the dapp side. We did this for simplicity and for security purposes. We believe that creating a connection should be very easy so there is no need to persist, but this may change in the future.\n\nIf the MetaMask Mobile app is completely closed without entering pause mode first, we close the connection as we believe it means the user is no longer using the wallet for any further actions.\n\n#### Close connections manually:\n\nIn order to close connections manually from the MetaMask Mobile app, you can go into\n\nSettings -> Experimental\n\n<img src=\"./images/sdk-clear-connections.png\" height=\"250\">","metadata":{"source":"metamask-sdk-concepts"}}],["129",{"pageContent":"Communication layer","metadata":{"source":"metamask-sdk-concepts"}}],["130",{"pageContent":"Security\n\nThe security layer is handled via the use of **ECIES** encryption.\n\n`Elliptic curve integrated encryption scheme` (ECIES) is a hybrid encryption scheme that combines the benefits of both symmetric and asymmetric encryption. It is a secure method of exchanging encrypted messages between two parties.\n\nIn ECIES, the sender (for example the **dAPP**) generates a shared secret using the recipient's public key (for example **MetaMask Mobile app**) and their own private key. The shared secret is used to encrypt the message using a symmetric cipher (the SDK used `AES-256-GCM`). The encrypted message is then combined with a message authentication code (`MAC`) and sent to the recipient.\n\nMetaMask mobile app uses their private key and the dApp's public key to recreate the shared secret and decrypt the message. The MAC is used to verify the authenticity of the message.","metadata":{"source":"metamask-sdk-concepts"}}],["131",{"pageContent":"MetaMask mobile app uses their private key and the dApp's public key to recreate the shared secret and decrypt the message. The MAC is used to verify the authenticity of the message.\n\nOne of the main benefits of ECIES is that it allows the sender and recipient to exchange messages without having to exchange a shared secret beforehand. It also provides security against eavesdropping and tampering, as the shared secret is derived from the sender's and recipient's private keys, which are both kept secret.\n\n![Sequence diagram](./images/sdk-comm-diagram.svg)","metadata":{"source":"metamask-sdk-concepts"}}],["132",{"pageContent":"# Exports\n\n::: tip Developer Preview Software\nSnaps is pre-release software. To try Snaps, install [MetaMask Flask](https://metamask.io/flask).\n:::\n\n::: tip Feature Requests\nDo you have feature requests? Other ideas? We'd love to hear about them! [Click here](https://github.com/MetaMask/snaps-monorepo/discussions) to join the discussion.\n:::\n\n## Table of Contents\n\n[[toc]]","metadata":{"source":"snaps-exports"}}],["133",{"pageContent":"`onRpcRequest`\n\nIn order to communicate with Dapps and other snaps, the snap must implement its own JSON-RPC API by exposing an exported function called `onRpcRequest`. Whenever the snap receives a JSON-RPC request, the `onRpcRequest` handler function will be called with the below parameters.\n\n::: tip Does my snap need to have an RPC API?\nWell, no, that's also up to you! If your snap can do something useful without receiving and responding to JSON-RPC requests, e.g. providing [transaction insights](#ontransaction), then you can skip exporting onRpcRequest. However, if you want to do something like manage the user's keys for a particular protocol and create a Dapp that sends transactions for that protocol via your snap, for example, you need to specify an RPC API.\n:::","metadata":{"source":"snaps-exports"}}],["134",{"pageContent":"::: warning Requesting the JSON-RPC permission\nIn order for the extension to call the `onRpcRequest` method of the snap, the `endowment:rpc` permission must be requested. See [Permissions](./snaps-permissions.html#endowment-rpc)\n:::","metadata":{"source":"snaps-exports"}}],["135",{"pageContent":"Parameters\n\n- `RpcHandlerArgs` - The origin and the JSON-RPC request.\n\n```typescript\nimport { JsonRpcRequest } from '@metamask/types';\n\ninterface RpcHandlerArgs {\n  origin: string;\n  request: JsonRpcRequest<unknown[] | { [key: string]: unknown }>;\n}\n```\n\n### Returns\n\n```typescript\ntype RpcHandlerReturn = Promise<unknown> | unknown;\n```\n\n`RpcHandlerReturn` - A promise containing the return of the implemented RPC Method.\n\n### Examples\n\n#### Typescript\n\n```typescript\nimport { OnRpcRequestHandler } from '@metamask/snap-types';\n\nexport const onRpcRequest: OnRpcRequestHandler = async ({\n  origin,\n  request,\n}) => {\n  switch (request.method) {\n    case 'hello':\n      return 'world!';\n\n    default:\n      throw new Error('Method not found.');\n  }\n};\n```\n\n#### Javascript\n\n```js\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  switch (request.method) {\n    case 'hello':\n      return 'world!';\n\n    default:\n      throw new Error('Method not found.');\n  }\n};\n```","metadata":{"source":"snaps-exports"}}],["136",{"pageContent":"`onTransaction`\n\nIf the snap wants to provide transaction insights before a user signs a transaction, the snap must export a function called `onTransaction`. Whenever there is a contract interaction and a transaction is submitted via the extension, this function will be called. The raw unsigned transaction payload will be passed to the `onTransaction` handler function.\n\n::: warning Requesting the transaction insight permission\nIn order for the extension to call the `onTransaction` method of the snap, the `endowment:transaction-insight` permission must be requested. See [Permissions](./snaps-permissions.html#endowment-transaction-insight) for more information.\n:::","metadata":{"source":"snaps-exports"}}],["137",{"pageContent":"Parameters\n\n- `onTransactionArgs` - the raw transaction payload, the [CAIP-2 chain ID](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md) and the transaction origin if [allowTransactionOrigin](./snaps-permissions.html#endowment-transaction-insight) is set to `true`. For more details on the transaction object see [SIP-3](https://metamask.github.io/SIPs/SIPS/sip-3#appendix-i-ethereum-transaction-objects).\n\n```typescript\ninterface OnTransactionArgs {\n  transaction: Record<string, unknown>;\n  chainId: string;\n  transactionOrigin?: string;\n}\n```\n\n::: warning Getting the `transactionOrigin` parameter\nThe `transactionOrigin` property is only passed to `onTransaction` if `allowTransactionOrigin` is set to `true` in the `endowment:transaction-insight` permission object. See [Permissions](./snaps-permissions.html#endowment-transaction-insight) for more information.\n:::","metadata":{"source":"snaps-exports"}}],["138",{"pageContent":"Returns\n\n```typescript\nimport { Component } from '@metamask/snaps-ui';\n\ntype OnTransactionHandlerReturn = Promise<OnTransactionResponse>;\n\ninterface OnTransactionResponse {\n  content: Component | null;\n}\n```\n\n- `onTransactionResponse` - The `content` object returned by the snap will be displayed using [Custom UI](./snaps-concepts.html#custom-ui) alongside the confirmation for the transaction that `onTransaction` was called with.","metadata":{"source":"snaps-exports"}}],["139",{"pageContent":"Examples\n\n#### Typescript\n\n```typescript\nimport { OnTransactionHandler } from '@metamask/snap-types';\nimport { panel, heading, text } from '@metamask/snaps-ui';\n\nexport const onTransaction: OnTransactionHandler = async ({\n  transactionOrigin\n  transaction,\n  chainId,\n}) => {\n  const insights = /* Get insights */;\n  return {\n    content: panel([\n      heading('My Transaction Insights'),\n      text('Here are the insights:'),\n      ...(insights.map((insight) => text(insight.value)))\n    ])\n  };\n};\n```\n\n#### Javascript\n\n```js\nimport { panel, heading, text } from '@metamask/snaps-ui';\n\nmodule.exports.onTransaction = async ({\n  transactionOrigin\n  transaction,\n  chainId,\n}) => {\n  const insights = /* Get insights */;\n  return {\n    content: panel([\n      heading('My Transaction Insights'),\n      text('Here are the insights:'),\n      ...(insights.map((insight) => text(insight.value)))\n    ])\n  };\n};\n```","metadata":{"source":"snaps-exports"}}],["140",{"pageContent":"`onCronjob`\n\nIf a snap wants to to run periodic actions for the user, the snap must export a function called `onCronjob`. This function will be called at the specified times with the specified payloads defined in the `endowment:cronjob` permission.\n\n::: tip Requesting the cronjob permission\nIn order for the extension to call the `onCronjob` method of the snap, the `endowment:cronjob` permission must be requested. See [Permissions](./snaps-permissions.html#endowment-cronjob)\n:::\n\n### Parameters\n\n- `onCronjobArgs` - exclusively containing an RPC request specified in the `endowment:cronjob` permission.\n\n```typescript\ninterface onCronjobArgs {\n  request: JsonRpcRequest<unknown[] | { [key: string]: unknown }>;\n}\n```","metadata":{"source":"snaps-exports"}}],["141",{"pageContent":"Examples\n\n#### Typescript\n\n```typescript\nimport { OnCronjobHandler } from '@metamask/snap-types';\n\nexport const onCronjob: OnCronjobHandler = async ({ request }) => {\n  switch (request.method) {\n    case 'exampleMethodOne':\n      return snap.request({\n        method: 'snap_notify',\n        params: {\n          type: 'inApp',\n          message: `Hello, world!`,\n        },\n      });\n\n    default:\n      throw new Error('Method not found.');\n  }\n};\n```\n\n#### Javascript\n\n```js\nmodule.exports.onCronjob = async ({ request }) => {\n  switch (request.method) {\n    case 'exampleMethodOne':\n      return snap.request({\n        method: 'snap_notify',\n        params: {\n          type: 'inApp',\n          message: `Hello, world!`,\n        },\n      });\n\n    default:\n      throw new Error('Method not found.');\n  }\n};\n```","metadata":{"source":"snaps-exports"}}],["142",{"pageContent":"# MetaMask iOS SDK\nThe MetaMask iOS SDK enables developers to connect their native iOS apps to the Ethereum blockchain via the MetaMask Mobile wallet, effectively enabling the creation of iOS native decentralised applications (Dapps).","metadata":{"source":"metamask-sdk-ios"}}],["143",{"pageContent":"Getting Started\nYou can import the MetaMask iOS SDK into your native iOS app to enable users to easily connect with their MetaMask Mobile wallet. Refer to the [MetaMask API Reference](https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/guide/rpc-api.html#table-of-contents) to see all the ethereum RPC methods available.","metadata":{"source":"metamask-sdk-ios"}}],["144",{"pageContent":"1. Install\n\n#### Cocoapods\nTo add MetaMask iOS SDK as a cocoapods dependency to your project, add this entry in your Podfile: \n```\n  pod 'metamask-ios-sdk'\n```\nAnd then run:\n```\npod install\n```\n#### Swift Package Manager\n##### Via Xcode Menu\nTo add MetaMask iOS SDK as an SPM package to your project, in Xcode select: `File -> Swift Packages -> Add Package Dependency`. And then enter this repository's url, i.e https://github.com/MetaMask/metamask-ios-sdk.\n\n##### Via Package file\n```swift\n    dependencies: [\n        .package(\n            url: \"https://github.com/MetaMask/metamask-ios-sdk\",\n            from: \"0.1.0\"\n        )\n    ]\n```\n\n#### Note\nPlease note that the SDK supports `ios-arm64` (iOS devices) and `ios-arm64-simulator` (M1 chip simulators). We currently do not support `ios-ax86_64-simulator` (Intel chip simulators).\n\n### 2. Import the SDK\n```\nimport metamask_ios_sdk\n```","metadata":{"source":"metamask-sdk-ios"}}],["145",{"pageContent":"2. Import the SDK\n```\nimport metamask_ios_sdk\n```\n\n### 3. Connect your Dapp\n```swift\n@ObservedObject var ethereum = MetaMaskSDK.shared.ethereum\n\n// We log three events: connection request, connected, disconnected, otherwise no tracking. \n// This helps us to monitor any SDK connection issues. \n//  \n\nlet dapp = Dapp(name: \"Dub Dapp\", url: \"https://dubdapp.com\")\n\n// This is the same as calling \"eth_requestAccounts\"\nethereum.connect(dapp)\n```\n\nWe log three SDK events: `connectionRequest`, `connected` and `disconnected`. Otherwise no tracking. This helps us to monitor any SDK connection issues. If you wish to disable this, you can do so by setting `MetaMaskSDK.shared.enableDebug = false` or `ethereum.enableDebug = false`.","metadata":{"source":"metamask-sdk-ios"}}],["146",{"pageContent":"4. You can now call any ethereum provider method\nWe use Combine to publish ethereum events, so you'll need an `AnyCancellable` storage.\n```swift\n@State private var cancellables: Set<AnyCancellable> = []\n```\n#### Example 1: Get Chain ID\n```swift\n@State var chainId: String?\n\nlet chainIdRequest = EthereumRequest(method: .ethChainId)\n\nethereum.request(chainIdRequest)?.sink(receiveCompletion: { completion in\n    switch completion {\n    case .failure(let error):\n        print(\"\\(error.localizedDescription)\")\n    default: break\n    }\n}, receiveValue: { result in\n    self.chainId = result\n})\n.store(in: &cancellables)  \n```","metadata":{"source":"metamask-sdk-ios"}}],["147",{"pageContent":"Example 2: Get account balance\n```swift\n@State var balance: String?\n\n// Create parameters\nlet parameters: [String] = [\n    ethereum.selectedAddress, // address to check for balance\n    \"latest\" // \"latest\", \"earliest\" or \"pending\" (optional)\n  ]\n  \n// Create request  \nlet getBalanceRequest = EthereumRequest(\n    method: .ethGetBalance,\n    params: parameters)\n\n// Make request\nethereum.request(getBalanceRequest)?.sink(receiveCompletion: { completion in\n    switch completion {\n    case .failure(let error):\n        print(\"\\(error.localizedDescription)\")\n    default: break\n    }\n}, receiveValue: { result in\n    self.balance = result\n})\n.store(in: &cancellables)  \n```","metadata":{"source":"metamask-sdk-ios"}}],["148",{"pageContent":"Example 3: Send transaction\n##### Using parameters dictionary\nIf your request parameters is a simple dictionary of string key-value pairs, you can use it directly. Note that the use of `Any` or even `AnyHashable` types is not supported as the type needs to be explicitly known.\n\n```swift\n// Create parameters\nlet parameters: [String: String] = [\n    \"to\": \"0x...\", // receiver address\n    \"from\": ethereum.selectedAddress, // sender address\n    \"value\": \"0x...\" // amount\n  ]\n    \n// Create request\nlet transactionRequest = EthereumRequest(\n    method: .ethSendTransaction,\n    params: [parameters] // eth_sendTransaction rpc call expects an array parameters object\n    )\n\n// Make a transaction request\nethereum.request(transactionRequest)?.sink(receiveCompletion: { completion in\n    switch completion {\n    case .failure(let error):\n        print(\"\\(error.localizedDescription)\")\n    default: break\n    }\n}, receiveValue: { result in\n    print(result)\n})\n.store(in: &cancellables)  \n```","metadata":{"source":"metamask-sdk-ios"}}],["149",{"pageContent":"Using a struct\n For a more complex parameters representation, you can define and use a struct that conforms to `CodableData` i.e implementing the requirement:\n ```\n func socketRepresentation() -> NetworkData\n ```\n so that the type can be represented as a socket packet.\n\n```swift\nstruct Transaction: CodableData {\n    let to: String\n    let from: String\n    let value: String\n    let data: String?\n\n    init(to: String, from: String, value: String, data: String? = nil) {\n        self.to = to\n        self.from = from\n        self.value = value\n        self.data = data\n    }\n\n    func socketRepresentation() -> NetworkData {\n        [\n            \"to\": to,\n            \"from\": from,\n            \"value\": value,\n            \"data\": data\n        ]\n    }\n}\n\nlet transaction = Transaction(\n    to: \"0x...\", // receiver address\n    from: ethereum.selectedAddress, // sender address\n    value: \"0x...\" // amount\n)","metadata":{"source":"metamask-sdk-ios"}}],["150",{"pageContent":"let transaction = Transaction(\n    to: \"0x...\", // receiver address\n    from: ethereum.selectedAddress, // sender address\n    value: \"0x...\" // amount\n)\n\nlet transactionRequest = EthereumRequest(\n    method: .ethSendTransaction,\n    params: [transaction] // eth_sendTransaction rpc call expects an array parameters object\n    )\n```\nThen make a request as shown in [Example 3](#example-3-send-transaction) above","metadata":{"source":"metamask-sdk-ios"}}],["151",{"pageContent":"Examples\nWe have created an [Example](./Example/) dapp as a guide on how to connect to ethereum and make requests. There are three illustrated examples:\n\n1) `ConnectView.swift` - Connect to the ethereum blockchain via the MetaMask SDK. The other examples are based on a successful connection as demonstrated in this example\n\n2) `TransactionView.swift` - Send a transaction\n\n3) `SignView.swift` - Sign a transaction\n\n4) `SwitchChainView.swift` - Switch to a different network chain (you need to call the `addEthereumChain` rpc call first if it doesn't already exist in the MetaMask wallet). \n\nTo run the example project, clone this repository, change directory to `metamask-ios-sdk/Example`, and then run `pod install` from the Example directory to install the SDK as a dependency on the project, and then open `metamask-ios-sdk.xcworkspace` and run the project.","metadata":{"source":"metamask-sdk-ios"}}],["152",{"pageContent":"You will need to have MetaMask Mobile wallet installed on your target i.e physical device or simulator, so you can either have it installed from the [App Store](https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202), or clone and compile MetaMask Mobile wallet from [source](https://github.com/MetaMask/metamask-mobile) and build to your target device.","metadata":{"source":"metamask-sdk-ios"}}],["153",{"pageContent":"Requirements\nThis SDK has an iOS minimum version requirement of 14.0. You need your app to have an iOS minimum deployment of no less than 14.0.","metadata":{"source":"metamask-sdk-ios"}}],["154",{"pageContent":"# Metamask Unity SDK\n\nThe MetaMask SDK for Unity.\n\n## How it works\n\nAs a developer you can import the MetaMask SDK into your Unity game to enable users to easily connect with their MetaMask Mobile wallet, The supported platforms are macOS, Windows, Linux, IOS, Android & WebGL\n\nThe SDK renders a QR code in the UI via a dedicated prefab which players can scan with their MetaMask Mobile app, we also support deep-linking on mobile platforms. Now you can use all the [`ethereum` methods available](guide/ethereum-provider.html) right from your game which you can learn more about in the above link.","metadata":{"source":"metamask-sdk-unity"}}],["155",{"pageContent":"Build Settings\n\nWhen building the SDK there is a couple of required changes be made to the unity editor when you would like to compile your build\n\n### IOS\n\n- Disable Enable Bitcode option in xcode from build settings\n- Scripting backend - IL2CPP\n- IL2CPP Code Generation - Faster Smaller Build\n\n### WebGL\n\n- Navigate to the player settings then navigate to the \"Resolution & Presentation Tab\" and then choose MetaMask\n- Scripting backend - IL2CPP\n- IL2CPP Code Generation - Faster Smaller Build\n\n### Android\n\n- Android Jar Resolver - Must be resolved before attempting build (Assets -> External Dependency Manager -> Android Resolver -> Resolve)\n- Scripting backend - IL2CPP\n- IL2CPP Code Generation - Faster Smaller Build\n- Minimum API level - Android 7.0 'Nougat' (API level 24)\n\n### Other Platforms\n\n- Scripting backend - IL2CPP\n- IL2CPP Code Generation - Faster Smaller Build","metadata":{"source":"metamask-sdk-unity"}}],["156",{"pageContent":"Getting started\n\nThis is a quick video tutorial explaining how to install and use MetaMask Unity SDK\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/0D1cIH-PZtI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n### 1. Install\n\nTo install the module, you first have to download the package via the Unity Asset Store which will make the asset available in your **Package Manager**.\n\nNow, you need to import it via the **Package Manager**. To do that, go to the Window menu > Package Manager. Select \"My Assets\" then select the \"MetaMask Unity SDK\" and click \"Install\", You should see the `MetaMask SDK` package now listed in the project packages and be able to interface with it and its examples in the scene.","metadata":{"source":"metamask-sdk-unity"}}],["157",{"pageContent":"Prerequisites\n\n- TextMesh Pro(If you do not have TMP installed you will be prompted to install it by the unity editor automatically, N.B\\* If you choose this path text will not appear until your first repaint)","metadata":{"source":"metamask-sdk-unity"}}],["158",{"pageContent":"2. Initialization\n\nThe main class you will be interfacing with is called `MetaMaskWallet` it handles the connection to the users wallet as well as processing the requests to it via a socket.io implementation, in order to use it inside Unity, you must attach the component called `MetaMaskUnity` to a gameobject within the editor, this component is a singleton and you can use its `Instance` property to access the Wallet instance, but before doing any of those, you need to initialize it either manually by calling `Initialize();`:\n\n```csharp\nMetaMaskUnity.Instance.Initialize();\n```\n\nOr just making sure that `Initialize On Start` is checked on the component within the editor, and then this will let you to enable you to make calls to the users wallet using [`ethereum` methods available](guide/ethereum-provider.html) as you would expect in a traditional development environment.\n\nThis will initialize the Wallet instance and then it becomes accessible from `MetaMaskUnity.Instance.Wallet`.","metadata":{"source":"metamask-sdk-unity"}}],["159",{"pageContent":"3. Connection\n\nOnce the wallet is now prepared and initialized, now you need to connect to the MetaMask app, all you need to do is to call the `Connect` method on the wallet instance like so:\n\n```csharp\nvar wallet = MetaMaskUnity.Instance.Wallet;\nwallet.Connect();\n```\n\nThen you can also subscribe to the `OnWalletConnected` callback on the wallet instance to be notified once the wallet is connected:\n\n```csharp\nwallet.WalletConnected += OnWalletConnected;\n\nvoid OnWalletConnected(object sender, EventArgs e) {\n    Debug.Log(\"Wallet is connected\");\n}\n```\n\nYou can also use the `Connect` method from `MetaMaskUnity` that just delegates the call to the Wallet instance:\n\n```csharp\nMetaMaskUnity.Instance.Connect();","metadata":{"source":"metamask-sdk-unity"}}],["160",{"pageContent":"You can also use the `Connect` method from `MetaMaskUnity` that just delegates the call to the Wallet instance:\n\n```csharp\nMetaMaskUnity.Instance.Connect();\n```\n\nThere are a variety of sample buttons included inside the package that you can use that call this method when clicked, these are provided as a convenience to you to get a kickstart with your project.\n\nOnce the connection request is made, a QR code will be generated, and based on the transport you're using, which is `Unity UI` by default, either spawns a new Canvas that contains the QR code or the `MetaMaskUnityUIQRImage` generates the QR code when the connection is requested, so if you want to use the latter, make sure to add an instance of the `MetaMaskUnityUIQRImage` component to the scene with its fields provided, the transport field is required too if you want to use it isolated from the canvas that is spawned by the transport, then it'll generate the QR code for you.","metadata":{"source":"metamask-sdk-unity"}}],["161",{"pageContent":"4. Usage\n\nNow you can make requests to the wallet once it is authorized, you'll notice that when the buttons become interactable or the `WalletAuthorized` event is fired:\n\n```csharp\nvar wallet = MetaMaskUnity.Instance.Wallet;\nwallet.WalletAuthorized += OnWalletAuthorized;\n\nvoid OnWalletAuthorized(object sender, EventArgs e) {\n    Deebug.Log(\"Wallet is authorized\");\n}\n```\n\nYou can now call any Ethereum request on the wallet by calling `wallet.Request(myRequest);`, here is a sample transaction request:\n\n```csharp\nvar wallet = MetaMaskUnity.Instance.Wallet;\nvar transactionParams = new MetaMaskTranscation\n{\n    To = \"0xd0059fB234f15dFA9371a7B45c09d451a2dd2B5a\",\n    From = MetaMaskUnity.Instance.Wallet.SelectedAddress,\n    Value = \"0x0\"\n};\n\nvar request = new MetaMaskEthereumRequest\n{\n    Method = \"eth_sendTransaction\",\n    Parameters = new MetaMaskTranscation[] { transactionParams }\n};\nawait wallet.Request(request);\n```","metadata":{"source":"metamask-sdk-unity"}}],["162",{"pageContent":"5. Config\n\nYou can customize the default configuration or creating your own config:\n\n#### Edit Default Config\n\nTo edit the default config you can do so by either opening the setup window through the `Window > MetaMask > Setup` menu item, or by opening the `MetaMaskConfig` asset in the project window, then you can edit the fields and save the changes.\n\n#### Create New Config\n\nTo create a new config, simply right-click on the project window and go to `MetaMask > Config` menu to create a new config, give it a name and then use it when initializing the `MetaMaskUnity` instance.","metadata":{"source":"metamask-sdk-unity"}}],["163",{"pageContent":"API\n\nHere is a quick overview of the APIs from the most important classes.","metadata":{"source":"metamask-sdk-unity"}}],["164",{"pageContent":"MetaMaskUnity\n\nThis is a singleton class that you can use to access the `MetaMaskWallet` instance which is specific to Unity.\n\n#### Instance\n\nThis is the singleton instance of the `MetaMaskUnity` class that is lazy-loaded when you access it for the first time.","metadata":{"source":"metamask-sdk-unity"}}],["165",{"pageContent":"Instance\n\nThis is the singleton instance of the `MetaMaskUnity` class that is lazy-loaded when you access it for the first time.\n\n#### Initialize\n\nThis method initializes the `MetaMaskWallet` instance and makes it accessible via the `Wallet` property.\n\nYou can also pass extra options and parameters to it to customize the wallet instance:\n\n```csharp\n// Initialize using default settings\nMetaMaskUnity.Instance.Initialize();\n\n// Initialize using custom transport and socket provider\nvar transport = new MyCustomTransport();\nvar socketProvider = new MyCustomSocketProvider();\nMetaMaskUnity.Instance.Initialize(transport, socketProvider);\n\n// Initialize using custom config, transport and socket provider\nvar config = myMetaMaskConfig;\nvar transport = new MyCustomTransport();\nvar socketProvider = new MyCustomSocketProvider();\nMetaMaskUnity.Instance.Initialize(config, transport, socketProvider);\n```","metadata":{"source":"metamask-sdk-unity"}}],["166",{"pageContent":"SaveSession\n\nThis method saves the current session to the persistent storage, this is useful when you want to save the session and restore it later on, this is automatically called when the application quits, but you can manually call it too.\n\n#### LoadSession\n\nThis method loads the session from the persistent storage, this is useful when you want to restore the session after the application quits, this is automatically called when the application starts, but you can manually call it too.","metadata":{"source":"metamask-sdk-unity"}}],["167",{"pageContent":"MetaMaskWallet\n\n#### Connect\n\nThis method connects to the MetaMask app, it will render a generated QRCode in the UI for your users to scan with the MetaMask Mobile app. After the user scan this QR code, a connect screen will appear in MetaMask Mobile where the user can now approve the connection with your game application.\n\n#### Disconnect\n\nThis method disconnects the user that is connected from the MetaMask app session.\n\n#### Request\n\nThis method is used to send a request to the MetaMask app, you can use it to call any `ethereum` method listed on the [the Ethereum Provider API](guide/ethereum-provider.html).","metadata":{"source":"metamask-sdk-unity"}}],["168",{"pageContent":"Package Structure\n\n- **Documentation**: contains the documentation and link to online documentation\n- **Editor**: contains the editor-only code such as Setup GUI windows, data persistence for SDK settings.\n- **Plugins**: contains the plugins needed by the package. In particular the ECIES Platform runtime libraries as well as the core SDK Codebase.\n- **Runtime**: contains the main scripts for the SDK that are environment agnostic, so they work fine in .NET, The `Runtime` folder contains the C# scripts that you need to import or use in your script for your project, they provide the base implementation of the SDK, you can create your own implementation of Unity components on top of these without ever toching the premade Unity component to have total control.\n- **Samples**: contains a test application scene that can be used as a referral for your project including modal popups and dynamic UI scaling.\n- **LICENSE.md**: the package license\n- **Third Party Notices.md**: third party notices","metadata":{"source":"metamask-sdk-unity"}}],["169",{"pageContent":"License\n\nCheck the `LICENSE` file for more information.","metadata":{"source":"metamask-sdk-unity"}}],["170",{"pageContent":"FAQS\n\n#### When I download the tool from the asset store i can’t find where to install it?\n\nThe first stage of the installation process is to navigate to the “tools” then “metamask” menu and you will see install options from there, if you do not see this options make sure you are on the latest unity version and that you have no “red “ errors printed in your console, A case of this menu not appearing is typically associated with incorrect editor initialization which can generally be resolved by restarting the editor or updating your unity version.\n\n#### On IOS why does a popup appear when utilizing a deeplink?\n\nWhen deeplinking a background service is created to facilitate the communication layer between the game application and the metamask app, On IOS there is a strict policy on how long a background service may life for before expiring hence why a notification is popped to let you know the socket connection has expired.","metadata":{"source":"metamask-sdk-unity"}}],["171",{"pageContent":"What does the external dependency manager do?\n\nThe Unity Jar Resolver is a specific external dependency manager for Unity projects that are using external libraries in their projects.\nIt helps manage the dependencies between Unity and external libraries, which can sometimes be complicated due to differences between the two environments.\nThis tool is particularly useful for the metamask SDK as on Android and IOS a variety of native libraries are needed to facilitate deeplinking and the persistent socket connection.\n\n#### Does the SDK increase my compilation time?\n\nNo it doesnt , if you are noticing an increased compilation time it may be related to the ILL2CP pipeline which can take longer to build at compile time but the SDK is filled with precompiled libraries to save runtime compilation.","metadata":{"source":"metamask-sdk-unity"}}],["172",{"pageContent":"# Best Practices\n\nIf this page doesn't answer your question, please feel free to open an issue [in our repository](https://github.com/MetaMask/metamask-mobile).","metadata":{"source":"mobile-best-practices"}}],["173",{"pageContent":"The Provider (window.ethereum)\n\n::: tip Recent Breaking Provider Changes\nIf you are an Ethereum application developer and are looking for information about our January 2021 provider API changes,\nplease see our [Migration Guide](./provider-migration.html) for more details.\n:::\n\nThe [provider API](./ethereum-provider.html) is the same for both MetaMask Mobile and the desktop extension.\nHowever, the providers become available (i.e., are injected into the page) at different points in the page lifecycle.","metadata":{"source":"mobile-best-practices"}}],["174",{"pageContent":"Provider Availability\n\nIf you use [`@metamask/detect-provider`](https://npmjs.com/package/@metamask/detect-provider), there's nothing to worry about; it will reliably detect both the mobile and extension provider.\n\nIf you don't use the `detect-provider` package, you have to detect the mobile provider manually.\n\nThe extension provider will always be available by the time your code is executed.\nBecause of platform limitations, the mobile provider may not be injected until later in the page lifecycle.\nFor this purpose, the MetaMask provider dispatches the event `ethereum#initialized` on `window` when it is fully initialized.\n\nYou can reliably detect both the mobile and extension provider with the following snippet.\n\n```javascript\nif (window.ethereum) {\n  handleEthereum();\n} else {\n  window.addEventListener('ethereum#initialized', handleEthereum, {\n    once: true,\n  });","metadata":{"source":"mobile-best-practices"}}],["175",{"pageContent":"```javascript\nif (window.ethereum) {\n  handleEthereum();\n} else {\n  window.addEventListener('ethereum#initialized', handleEthereum, {\n    once: true,\n  });\n\n  // If the event is not dispatched by the end of the timeout,\n  // the user probably doesn't have MetaMask installed.\n  setTimeout(handleEthereum, 3000); // 3 seconds\n}\n\nfunction handleEthereum() {\n  const { ethereum } = window;\n  if (ethereum && ethereum.isMetaMask) {\n    console.log('Ethereum successfully detected!');\n    // Access the decentralized web!\n  } else {\n    console.log('Please install MetaMask!');\n  }\n}\n```","metadata":{"source":"mobile-best-practices"}}],["176",{"pageContent":"Using WalletConnect\n\nWith WalletConnect, you can use MetaMask Mobile as a signer while using applications on another browser, desktop, or mobile application.\nCheck out the [WalletConnect mobile linking docs](https://docs.walletconnect.org/mobile-linking) for more info.","metadata":{"source":"mobile-best-practices"}}],["177",{"pageContent":"Deeplinking\n\n::: tip Tip\n[Click here to create deeplinks for your application.](https://metamask.github.io/metamask-deeplinks/#)\n:::\n\nDeeplinks enable instant invocation of the user's preferred wallet application with correctly parameterized transactions.\n\nOnly the (authenticated) user can confirm the transaction, and the wallet can be a web, mobile or desktop app.\n\nURLs embedded in QR codes, hyperlinks in web pages, emails, or chat messages enable robust, cross-application signaling between otherwise loosely coupled applications.\n\nYou can use deeplinks for things like:\n\n- Creating a URL so your users can open your app directly in MetaMask Mobile to interact with your application with their Ethereum account.\n\n- Providing a one-click experience such that users can easily make payments to another account (with pre-filled parameters like recipient address, amount, network, etc.)","metadata":{"source":"mobile-best-practices"}}],["178",{"pageContent":"- Providing a one-click experience such that users can easily make payments to another account (with pre-filled parameters like recipient address, amount, network, etc.)\n\n- Let your users make gasless and instant transactions with Connext payment channel requests\n  - This requires that the user opts in for the InstaPay experimental feature.","metadata":{"source":"mobile-best-practices"}}],["179",{"pageContent":"Website Testing and Debugging\n\nTest and debug your web3 site using MetaMask Mobile on any iOS or Android device with ease.\n\n### Testing\n\n1. Configure your development server to run on your host machine's local IP address `192.168.x.x`, or `0.0.0.0`.\n2. Make sure your testing device is using the same WiFi connection as the machine hosting the server.\n3. In the MetaMask Mobile web browser, navigate to your website at `http://YOUR_LOCAL_IP:PORT`.\n\n::: tip Tip\nIf you're using an Android device, you must use `sslip` in your url. Example: `http://192.168.x.x.sslip.io:8000`\n:::","metadata":{"source":"mobile-best-practices"}}],["180",{"pageContent":"Debugging\n\n::: warning Important\nFor security purposes, web browser debugging on both iOS and Android will not work if the app was downloaded through the Apple App Store or Google Play Store.\nYou must build the app locally from [MetaMask Mobile repository](https://github.com/MetaMask/metamask-mobile) and run it on a simulator or physical device.\n:::\n\n#### iOS\n\n1. Open **Safari Preferences** -> **Advanced** -> enable the **Show Develop menu in menu bar** checkbox\n2. Open MetaMask Mobile in an iOS simulator or iOS device\n3. In the Safari menu bar -> **Develop** -> **[device name]** -> **[app name]** -> **[url - title]**\n\n::: tip Tip\nWhen debugging on a physical device, you must enable Web Inspector in your device's settings:\n\n**Settings** -> **Safari** -> **Advanced** -> **Web Inspector**\n:::","metadata":{"source":"mobile-best-practices"}}],["181",{"pageContent":"Android\n\n1. Open MetaMask Mobile in an Android emulator or Android device\n2. Open Google Chrome's DevTools -> menu (3 dots) -> **More tools** -> **Remote devices**\n   You may also navigate to `chrome://inspect` from Chrome to display the list of available devices for debugging\n3. Select your device on the left and click **Inspect** on the browser contents you'd like to inspect.\n\n::: tip Tip\nWhen debugging on a physical device you must enable USB debugging in your device's settings:\n\n**Settings** -> **System** -> **About Phone** -> **Developer options** -> **Enable USB debugging**\n:::\n\nYou can now debug MetaMask Mobile's browser contents just as you would on the web!","metadata":{"source":"mobile-best-practices"}}],["182",{"pageContent":"# Concepts\n\n[[toc]]","metadata":{"source":"snaps-concepts"}}],["183",{"pageContent":"Accounts and Key Management\n\nThe Snaps API contains functionality that allows you to manage users' private keys, with their approval. This capability comes with great responsibility on part of the developer: Misplaced or stolen private keys may lead to a complete loss of funds for users of the snap. Below are some guidelines to help snap developers assess the feasibility and sanity of their snaps.","metadata":{"source":"snaps-concepts"}}],["184",{"pageContent":"Key Management Guidelines\n\nThe general guideline for responsible key management is:\n\n> Don't create a situation where your user can lose assets\n\nIn practice, here are some examples that would break this:\n\n1. Allowing extraction of private keys outside the snap in any way, especially through RPC or network connections\n2. Execution of arbitrary/untrusted code with access to private keys.\n3. Not getting properly informed consent before doing a irreversible operation (for example submission of a signature or transaction).\n4. Asking for consent but ignoring the decision.\n5. Exposing key material in clear-text.\n6. A bug that leads to any of the above.\n\nAnd here are some examples of abiding by the above policy:","metadata":{"source":"snaps-concepts"}}],["185",{"pageContent":"And here are some examples of abiding by the above policy:\n\n1. Deriving private keys and/or storing them in Snaps persistent storage, without them ever leaving the Snaps Secure ECMAScript sandbox.\n2. Arbitrary code execution without access to destructive operations nor private keys.\n3. Doing destructive operations -- for example transactions --, one, multiple, or even creating an allowance without further confirmations, with prior informing the user of what's going to happen in an a way that a layman can understand and asking for consent.","metadata":{"source":"snaps-concepts"}}],["186",{"pageContent":"How to derive keys\n\nTo derive a user's private keys, you need to:\n\n1. Figure out whether you'll be using the BIP-32 or BIP-44 specifications to derive the user's private keys. BIP-44 is more strict in the structure and shape of the derivation paths, while BIP-32 allows for more flexibility.\n2. Find out the derivation path that you need to use. For example, if you're trying to derive keys for Dogecoin, the path is of the form `m/44'/3'/0'/0/{address_index}`.\n3. Add the required permission to your manifest file.\n4. Write code in your snap to derive the keys. This will typically be done using the `@metamask/key-tree` package. Any further code to e.g. derive addresses from keys will be application-specific.","metadata":{"source":"snaps-concepts"}}],["187",{"pageContent":"Figuring out whether to use BIP-32 or BIP-44\n\nIf the keys you are trying to derive conform to the BIP-44 structure, that is:\n\n```\nm / purpose' / coin_type' / account' / change / address_index\n```\n\nThen you should use [`snap_getBip44Entropy`](./snaps-rpc-api.html#snap-getbip44entropy) to derive your keys. Its permissions are simpler, since it requires only a coin type.\n\nIf the key you are trying to derive do not conform to the BIP-44 structure, then you should use [`snap_getBip32Entropy`](./snaps-rpc-api.html#snap-getbip32entropy).\n\n### Finding out the derivation path\n\nThe derivation path is completely dependent on the application you're building. As an example, if you're trying to reproduce the Dogecoin derivation path, that would be:\n\n```\nm/44'/3'/0'/0/{address_index}\n```\n\nThis means that you'd be using [`snap_getBip44Entropy`](./snaps-rpc-api.html#snap-getbip44entropy) with the permission `coinType` having a value of `3`.","metadata":{"source":"snaps-concepts"}}],["188",{"pageContent":"Adding permissions to the manifest file\n\nFor `snap_getBip44Entropy`, you only need to specify the `coinType`, like this:\n\n```json\n{\n  \"initialPermissions\": {\n    \"snap_getBip44Entropy\": [\n      {\n        \"coinType\": 3 // 3 is Dogecoin\n      }\n    ]\n  }\n}\n```\n\nThe authoritative list of coin types is defined in [`SLIP-44`](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).","metadata":{"source":"snaps-concepts"}}],["189",{"pageContent":"Example of private key derivation\n\nAs an example, to derive Dogecoin keys:\n\n1. Dogecoin uses the BIP-44 scheme so we'll be using [`snap_getBip44Entropy`].\n2. Dogecoin has coin type `3`, so our manifest file will have the following:\n\n   ```json\n   {\n     \"initialPermissions\": {\n       \"snap_getBip44Entropy\": [\n         {\n           \"coinType\": 3\n         }\n       ]\n     }\n     // Other values\n   }\n   ```\n\n3. Dogecoin uses the following derivation path:\n\n   ```\n   m/44'/3'/0'/0/{address_index}","metadata":{"source":"snaps-concepts"}}],["190",{"pageContent":"3. Dogecoin uses the following derivation path:\n\n   ```\n   m/44'/3'/0'/0/{address_index}\n   ```\n\n   To get the second Dogecoin account, we would write the following code:\n\n   ```javascript\n   import { getBIP44AddressKeyDeriver } from '@metamask/key-tree';\n\n   // Get the Dogecoin node, corresponding to the path m/44'/3'\n   const dogecoinNode = await snap.request({\n     method: 'snap_getBip44Entropy',\n     params: {\n       coinType: 3,\n     },\n   });\n\n   /**\n    * Creates a function that takes an index and returns an extended private key for m/44'/3'/0'/0/address_index\n    * The second parameter to getBIP44AddressKeyDeriver is not passed. This sets account and change to 0\n    */\n   const deriveDogecoinAddress = await getBIP44AddressKeyDeriver(dogecoinNode);\n\n   // Derive the second Dogecoin address, which has index 1\n   const secondAccount = deriveDogecoinAddress(1);\n   ```","metadata":{"source":"snaps-concepts"}}],["191",{"pageContent":"Custom UI\n\n### Introduction\n\nCustom UI is a UI definition system used by various Snaps features. It enables Snaps to describe a rich UI to be displayed in some contexts.\n\nCustom UI is used to describe custom user interfaces in [`snap_dialog`](./snaps-rpc-api.html#snap-dialog), and in the [`onTransaction` export](./snaps-exports.html#ontransaction).\n\n### How to use it\n\nTo use Custom UI, you must first install the `@metamask/snaps-ui` NPM package:\n\n```sh\nyarn add @metamask/snaps-ui\n```\n\nThen, whenever you're required to return a Custom UI, import the components you need from the package, and build your UI with them. For example:\n\n```javascript\nimport { panel, heading, text } from '@metamask/snaps-ui';\n\n// ...\n\nconst content = panel([\n  heading('Alert heading'),\n  text('Something happened in the system.'),\n]);\n\nreturn content;\n```","metadata":{"source":"snaps-concepts"}}],["192",{"pageContent":"Components\n\nThe `NodeType` enum exported by `@metamask/snaps-ui` details the available components.\n\n#### `Copyable`\n\n##### Description\n\nOutputs a read-only text field with a copy-to-clipboard shortcut.\n\n##### Usage\n\n```javascript\nimport { copyable } from '@metamask/snaps-ui';\n\n// ...\n\nconst content = copyable('Text to be copied');\n```\n\n#### `Divider`\n\n##### Description\n\nOutputs a horizontal divider.\n\n##### Usage\n\n```javascript\nimport { panel, divider, text } from '@metamask/snaps-ui';\n\n// ...\n\nconst content = panel([\n  text('Text before the divider'),\n  divider(),\n  text('Text after the divider'),\n]);\n```\n\n#### `Heading`\n\n##### Description\n\nOutputs a heading. Useful for panel titles.\n\n##### Usage\n\n```javascript\nimport { panel, heading, text } from '@metamask/snaps-ui';\n\n// ...\n\nconst content = panel([\n  heading('Title of the panel'),\n  text('Text of the panel'),\n]);\n```","metadata":{"source":"snaps-concepts"}}],["193",{"pageContent":"`Panel`\n\n##### Description\n\nOutputs a panel, which can be used as a container for other components.\n\n##### Usage\n\n```javascript\nimport { panel, heading, text } from '@metamask/snaps-ui';\n\n// ...\n\nconst insights = [\n  /*...*/\n];\nconst content = panel([\n  heading('Here are the transaction insights'),\n  ...insights.map((insight) => text(insight.description)),\n]);\n```\n\n#### `Spinner`\n\n##### Description\n\nOutputs a loading indicator.\n\n##### Usage\n\n```javascript\nimport { panel, heading, spinner } from '@metamask/snaps-ui';\n\n// ...\n\nconst content = panel([heading('Please wait...'), spinner()]);\n```\n\n#### `Text`\n\n##### Description\n\nOutputs text.\n\n##### Usage\n\n```javascript\nimport { text } from '@metamask/snaps-ui';\n\n// ...\n\nconst content = text('This is a simple text UI');\n```","metadata":{"source":"snaps-concepts"}}],["194",{"pageContent":"Markdown\n\nText-based components accept a very small subset of Markdown, that is, `**bold**` and `_italic_`. There are plans to increase this subset in the future.","metadata":{"source":"snaps-concepts"}}],["195",{"pageContent":"# Introduction\n\n::: tip Snaps is pre-release software.\nTo try Snaps, install [MetaMask Flask](https://metamask.io/flask).\n:::","metadata":{"source":"snaps"}}],["196",{"pageContent":"Extend the functionality of MetaMask\n\nSnaps is a system that allows anyone to safely extend the capabilities of MetaMask. A _snap_ is a program that we run in an isolated environment that can customize the wallet experience.\n\nFor example, a snap can add new APIs to MetaMask, add support for different blockchain protocols, or modify existing functionality using internal APIs. Snaps is a new way to create web3 end user experiences, by modifying MetaMask in ways that were impossible before.","metadata":{"source":"snaps"}}],["197",{"pageContent":"JSON-RPC API\n\nSnaps are run in an isolated environment where they have access to a limited set of capabilities, determined by the permissions they were granted by the user during installation.\nAs with MetaMask’s [Ethereum Provider RPC API](./rpc-api.html), snaps communicate with MetaMask using JSON-RPC.\n\nNew JSON-RPC methods for snaps have been added to our JSON-RPC API, which are documented as part of the [Snaps JSON-RPC API](./snaps-rpc-api.html).\nThese new methods are what allow snaps to modify the functionality of MetaMask.\nIn addition, they also allow websites to install and communicate with individual snaps.","metadata":{"source":"snaps"}}],["198",{"pageContent":"Execution environment\n\nSnaps are untrusted JavaScript programs that execute safely inside the MetaMask application. To isolate snaps from the rest of the application and to provide a “fully virtualizable” execution environment, MetaMask uses [Secure ECMAScript (SES)](https://github.com/endojs/endo/tree/master/packages/ses), a subset of JavaScript developed by [Agoric](https://agoric.com/).\n\nAmong other things, SES allows us to restrict access to global JavaScript APIs and to isolate untrusted code from other parts of the application. SES does this at the cost of some performance and incompatibility with some JavaScript practices, such as modifying prototypes of intrinsic objects (e.g. the `Promise` constructor).","metadata":{"source":"snaps"}}],["199",{"pageContent":"Features\n\nAt present, snaps can (1) create new RPC methods for websites to call, (2) call many of the same RPC methods that websites can call, and (3) access a limited set of snap-exclusive RPC methods.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative; top: 20px;\" />\n\n#### Display a custom confirmation screen in MetaMask &bull; [Learn more](./snaps-rpc-api.html#snap-confirm)\n\nShow a MetaMask popup with custom text and buttons to approve or reject an action. This can be used to create requests, confirmations, and opt-in flows for a snap.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative; top: 20px;\" />","metadata":{"source":"snaps"}}],["200",{"pageContent":"Notify users in MetaMask &bull; [Learn more](./snaps-rpc-api.html#snap-notify)\n\nMetaMask Flask introduces a generic notifications interface that can be utilized by any snap with the notifications permission. A short notification text can be triggered by a snap for actionable or time-sensitive information.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative;top: 20px;\" />\n\n#### Store and manage data on your device &bull; [Learn more](./snaps-rpc-api.html#snap-managestate)\n\nStore, update, and retrieve data securely, with encryption by default.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative;top: 20px;\" />","metadata":{"source":"snaps"}}],["201",{"pageContent":"Control non-EVM accounts and assets in MetaMask &bull; [Learn more](./snaps-rpc-api.html#snap-getbip44entropy)\n\nDerive BIP-32 and BIP-44 keypairs based on the Secret Recovery Phrase without exposing it. With the power to manage keys, you can build snaps to support a variety of blockchain protocols.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative;top: 20px;\" />\n\n#### Populate MetaMask's pre-transaction window with custom transaction insights &bull; [Learn more](./snaps-exports.html#ontransaction)\n\nBring your insights, anti-phishing, and security solutions to the MetaMask UI with the transaction insights API.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative;top: 20px;\" />","metadata":{"source":"snaps"}}],["202",{"pageContent":"Schedule actions with cron jobs &bull; [Learn more](./snaps-exports.html#oncronjob)\n\nPerform actions that run periodically at fixed times, dates, or intervals.\n\n<img src=\"../assets/flask.png\" alt=\"Live in MetaMask Flask\" style=\"width: 171px; position: relative;top: 20px;\" />\n\n#### Custom UI in MetaMask using a defined set of components\n\nDisplay [Custom UI](./snaps-concepts.html#custom-ui) within MetaMask using a set of pre-defined components, including inline Markdown.","metadata":{"source":"snaps"}}],["203",{"pageContent":"Propose a feature\n\nCreate a feature proposal with your ideas in our [GitHub discussion board](https://github.com/MetaMask/snaps-monorepo/discussions).","metadata":{"source":"snaps"}}],["204",{"pageContent":"Getting started\n\nLet's extend the functionality of MetaMask and build the wallet experience of the future.\n\n### Prerequisites\n\n- Up-to-date Chromium or Firefox browser\n- [Node.js](https://nodejs.org/)\n- MetaMask Flask\n\n  To interact with (your) snaps, you will need to install [MetaMask Flask](https://metamask.io/flask/), a canary distribution for developers that provides access to upcoming features.\n\n  ::: warning\n  Make sure to install Flask in a new browser profile or disable any existing installed versions of MetaMask. Running multiple instances of MetaMask in the same browser profile will break Dapp interactions.\n  :::","metadata":{"source":"snaps"}}],["205",{"pageContent":"Quick start using our template\n\nGet started with Snaps using [our template](https://github.com/MetaMask/template-snap-monorepo) built with TypeScript and React. Create the repository [via GitHub](https://github.com/MetaMask/template-snap-monorepo/generate) and [clone it](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository) down to your local machine using e.g. the command line.\n\n> NB: Snaps should work with the latest LTS version of Node.js, but we recommend using the version specified in the template's `.nvmrc` file. If you use [nvm](https://github.com/nvm-sh/nvm) you can switch easily with calling `nvm use` at the root of the project.\n\nFrom the root of the repo, install the dependencies:\n\n```shell\nyarn\n```\n\nStart the development server:\n\n```shell\nyarn start\n```\n\nYou should now be serving both (1) the front-end and (2) the snap locally. Time to check it out in action at [`http://localhost:8000/`](http://localhost:8000/).","metadata":{"source":"snaps"}}],["206",{"pageContent":"Connecting to the snap\n\nOnce you have the [development environment](./snaps.html#quick-start-using-our-template) running, you should be able to **connect** and **install** the snap.\n\n1. Click the **Connect** button and the MetaMask Flask extension should pop up and require you to approve the template snap's permissions.\n\n2. Once connected, try out the **Send message** button to display a custom message within a confirmation screen in MetaMask.\n\nYou've now successfully connected, installed, and interacted with your snap.","metadata":{"source":"snaps"}}],["207",{"pageContent":"Let's start building\n\nCustomize your snap by editing and expanding `index.ts` in the `packages/snap/src` folder.\n\nInitially it contains an example request that utilizes the `snap_confirm` method to display a custom confirmation screen:\n\n```ts\nimport { OnRpcRequestHandler } from '@metamask/snap-types';\nimport { getMessage } from './message';\n\nexport const onRpcRequest: OnRpcRequestHandler = ({ origin, request }) => {\n  switch (request.method) {\n    case 'hello':\n      return snap.request({\n        method: 'snap_confirm',\n        params: [\n          {\n            prompt: getMessage(origin),\n            description:\n              'This custom confirmation is just for display purposes.',\n            textAreaContent:\n              'Edit the source code to make your snap do what you want.',\n          },\n        ],\n      });\n    default:\n      throw new Error('Method not found.');\n  }\n};","metadata":{"source":"snaps"}}],["208",{"pageContent":"Modify the text in the `description` or `textAreaContent` field and click the **Reconnect** button to reinstall the snap.\n\n::: tip Local Snap Reinstallation\nMetaMask automatically reinstalls locally hosted snaps whenever it receives a connection request for them.\n:::\n\nThe next time you click the **Send message** button, you will see the updated text in the confirmation screen. _This flow will be improved in the next update to the template-snap-monorepo._","metadata":{"source":"snaps"}}],["209",{"pageContent":"Next up\n\nIf you're interested in building your own snap, next up is the [Snaps development guide](./snaps-development-guide.html).\n\n## Need help?\n\nIf you have questions, proposals, or need help with anything related to Snaps, you're always welcome to ask our team and community on [GitHub discussions](https://github.com/MetaMask/snaps-monorepo/discussions).","metadata":{"source":"snaps"}}],["210",{"pageContent":"# Provider Migration Guide\n\n::: tip Attention MetaMask Users\nIf you are a MetaMask user attempting to use a legacy Ethereum website that hasn't migrated to the new API,\nplease see the section on the [MetaMask Legacy Web3 Extension](#using-the-metamask-legacy-web3-extension).\n\nExcept for such legacy websites, no action is required for MetaMask users.\n:::\n\nIn January of 2021, we made a number of breaking changes to our provider API, and removed our injected `window.web3`.\nThese changes are live on all platforms as of version:\n\n- `9.0.2` of the MetaMask browser extension\n- `1.0.9` of MetaMask Mobile\n\nThis guide describes how to migrate to the new provider API, and how to replace our `window.web3`.\nTo understand why we made these changes, please see [this blog post](https://medium.com/metamask/breaking-changes-to-the-metamask-provider-are-here-7b11c9388be9).\n\n## Table of Contents\n\n[[toc]]","metadata":{"source":"provider-migration"}}],["211",{"pageContent":"Summary of Breaking Changes\n\n### `window.web3` Removal\n\nAs part of the breaking changes, we stopped injecting `web3.js` version `0.20.7` as `window.web3` into web pages.\nMetaMask still injects a dummy object at `window.web3`, in order to issue warnings when websites attempt to access `window.web3`.","metadata":{"source":"provider-migration"}}],["212",{"pageContent":"`window.ethereum` API Changes\n\nWe made the following breaking changes to the `window.ethereum` API:","metadata":{"source":"provider-migration"}}],["213",{"pageContent":"- Ensure that chain IDs returned by `eth_chainId` are **not** 0-padded\n  - For example, instead of `0x01`, we always return `0x1`, wherever the chain ID is returned or accessible.\n  - Note that this _only_ affects the [default Ethereum chains](./ethereum-provider.html#chain-ids), _except_ Kovan, whose chain ID is formatted correctly (`0x2a`).\n- Stop emitting `chainIdChanged`, and instead emit `chainChanged`\n- Remove the following experimental methods:\n  - `ethereum._metamask.isEnabled`\n  - `ethereum._metamask.isApproved`\n- Remove the `ethereum.publicConfigStore` object\n  - This object was, despite its name, never intended for public consumption.\n    Its removal _may_ affect those who do not use it directly, e.g. if another library you use relies on the object.\n- Remove the `ethereum.autoRefreshOnNetworkChange` property\n  - Consumers can still set this property on the provider, it just won't do anything.\n- Deprecate the `web3.currentProvider` method","metadata":{"source":"provider-migration"}}],["214",{"pageContent":"- Remove the `ethereum.autoRefreshOnNetworkChange` property\n  - Consumers can still set this property on the provider, it just won't do anything.\n- Deprecate the `web3.currentProvider` method\n  - Use [@metamask/detect-provider](https://github.com/MetaMask/detect-provider) to detect the current provider.","metadata":{"source":"provider-migration"}}],["215",{"pageContent":"Replacing `window.web3`\n\n::: warning Pages No Longer Reload on Chain Changes\nSince we removed our `window.web3`, MetaMask no longer automatically reloads the page on chain/network changes.\n\nPlease see [Handling the Removal of `ethereum.autoRefreshOnNetworkChange`](#handling-the-removal-of-ethereum-autorefreshonnetworkchange) for details.\n:::\n\nFor historical reasons, MetaMask injected [`web3@0.20.7`](https://github.com/ethereum/web3.js/tree/0.20.7) into all web pages.\nThat version of `web3` is deprecated, [has known security issues](https://github.com/ethereum/web3.js/issues/3065), and is no longer maintained by the [web3.js](https://github.com/ethereum/web3.js/) team.\nTherefore, we decided to remove this library.\n\nIf your website relied on our `window.web3` object, you have to migrate.\nPlease continue reading to understand your options.\nSome are as simple as a one-line change.","metadata":{"source":"provider-migration"}}],["216",{"pageContent":"If your website relied on our `window.web3` object, you have to migrate.\nPlease continue reading to understand your options.\nSome are as simple as a one-line change.\n\n::: tip Tip\nRegardless of how you choose to migrate, you may want to read the `web3@0.20.7` documentation, which you can find [here](https://github.com/ethereum/web3.js/blob/0.20.7/DOCUMENTATION.md).\n:::","metadata":{"source":"provider-migration"}}],["217",{"pageContent":"Using `window.ethereum` Directly\n\nFor many web3 sites, the API provided by `window.ethereum` is sufficient.\nMuch of the `web3` API simply maps to RPC methods, all of which can be requested using [`ethereum.request()`](./ethereum-provider.html#ethereum-request-args).\nFor example, here are a couple of actions performed using first `window.web3`, and then their equivalents using `window.ethereum`.\n\n<<< @/docs/snippets/web3ToProvider.js\n\n### Using an Updated Convenience library\n\nIf you decide that you need a convenience library, you have to convert your usage of `window.web3` to an updated convenience library.\nWe recommend [`ethers`](https://npmjs.com/package/ethers) ([documentation](https://docs.ethers.io/)).","metadata":{"source":"provider-migration"}}],["218",{"pageContent":"Using `@metamask/legacy-web3`\n\n::: warning\nWe strongly recommend that you consider one of the other two migration paths before resorting to this one.\nIt is not future-proof, and we will not add new features to it.\n:::\n\nFinally, if you just want your web3 site to continue to work, we created [`@metamask/legacy-web3`](https://npmjs.com/package/@metamask/legacy-web3).\nThis package is a drop-in replacement for our `window.web3` that you can add to your website even before remove `window.web3` on all platforms.\n\n`@metamask/legacy-web3` should work exactly like our injected `window.web3`, including by refreshing the page on chain/network changes, but _we cannot guarantee that it works perfectly_.\nWe will not fix any future incompatibilities between `web3@0.20.7` and MetaMask itself, nor will we fix any bugs in `web3@0.20.7` itself.\n\nFor installation and usage instructions, please see the [npm listing](https://npmjs.com/package/@metamask/legacy-web3).","metadata":{"source":"provider-migration"}}],["219",{"pageContent":"Using the MetaMask Legacy Web3 Extension\n\nWe created the [**MetaMask Legacy Web3 Extension**](https://github.com/MetaMask/legacy-web3-extension) for any users of websites that still expect `window.web3` to be injected. If you install this extension alongside the regular MetaMask wallet extension, websites that rely on our old window.web3 API should start working again.\n\nAs with the regular extension, it’s critical that you only install from the official browser extension stores. Please follow the relevant link below to install the Legacy Web3 extension in your browser:\n\n- [Edge](https://microsoftedge.microsoft.com/addons/detail/metamask-legacy-web3/obkfjbjkiofoponpkmphnpaaadebfloh?hl=en-US)\n- [Firefox](https://addons.mozilla.org/en-US/firefox/addon/metamask-legacy-web3/)","metadata":{"source":"provider-migration"}}],["220",{"pageContent":"Migrating to the New Provider API\n\n### Handling `eth_chainId` Return Values\n\nThe `eth_chainId` RPC method now returns correctly formatted values, e.g. `0x1` and `0x2`, instead of _incorrectly_ formatted values, e.g. `0x01` and `0x02`.\nMetaMask's implementation of `eth_chainId` used to return 0-padded values for the [default Ethereum chains](./ethereum-provider.html#chain-ids) _except_ Kovan.\nIf you expect 0-padded chain ID values from `eth_chainId`, make sure to update your code to expect the correct format instead.\n\nFor more details on chain IDs and how to handle them, see the [`chainChanged` event](./ethereum-provider.html#chainchanged).\n\n### Handling the Removal of `chainIdChanged`\n\n`chainIdChanged` is a typo of `chainChanged`.\nTo migrate, simply listen for `chainChanged` instead:\n\n```javascript\n// Instead of this:\nethereum.on('chainIdChanged', (chainId) => {\n  /* handle the chainId */\n});\n\n// Do this:\nethereum.on('chainChanged', (chainId) => {\n  /* handle the chainId */\n});\n```","metadata":{"source":"provider-migration"}}],["221",{"pageContent":"Handling the Removal of `isEnabled()` and `isApproved()`\n\nBefore the new provider API shipped, we added the `_metamask.isEnabled` and `_metamask.isApproved` methods\nto enable web3 sites to check if they have [access to the user's accounts](./rpc-api.html#eth-requestaccounts).\n`isEnabled` and `isApproved` functioned identically, except that `isApproved` was `async`.\nThese methods were arguably never that useful, and they became completely redundant with the introduction of MetaMask's [permission system](./rpc-api.html#restricted-methods).\n\nWe recommend that you check for account access in the following ways:\n\n1. You can call the [`wallet_getPermissions` RPC method](./rpc-api.html#wallet-getpermissions) and check for the `eth_accounts` permission.\n\n2. You can call the `eth_accounts` RPC method and the [`ethereum._metamask.isUnlocked()` method](./ethereum-provider.html#ethereum-metamask-isunlocked).","metadata":{"source":"provider-migration"}}],["222",{"pageContent":"2. You can call the `eth_accounts` RPC method and the [`ethereum._metamask.isUnlocked()` method](./ethereum-provider.html#ethereum-metamask-isunlocked).\n\n   - MetaMask has to be unlocked before you can access the user's accounts.\n     If the array returned by `eth_accounts` is empty, check if MetaMask is locked using `isUnlocked()`.\n\n   - If MetaMask is unlocked and you still aren't receiving any accounts, it's time to request accounts using the [`eth_requestAccounts` RPC method](./rpc-api.html#eth-requestaccounts).","metadata":{"source":"provider-migration"}}],["223",{"pageContent":"Handling the Removal of `ethereum.publicConfigStore`\n\nHow to handle this change depends on if and how you relied on the `publicConfigStore`.\nWe have seen examples of listening for provider state changes the `publicConfigStore` `data` event, and accessing the `publicConfigStore` internal state directly.\n\nWe recommend that you search your code and its dependencies for references to `publicConfigStore`.\nIf you find any references, you should understand what it's being used for, and migrate to [one of the recommended provider APIs](./ethereum-provider.html#using-the-provider) instead.\nIf you don't find any references, you should not be affected by this change.\n\nAlthough it is possible that your dependencies use the `publicConfigStore`, we have confirmed that the latest versions (as of January 2021) of the following common libraries were not affected by this change:\n\n- `ethers`\n- `web3` (web3.js)","metadata":{"source":"provider-migration"}}],["224",{"pageContent":"Handling the Removal of `ethereum.autoRefreshOnNetworkChange`\n\nThe `ethereum.autoRefreshOnNetworkChange` was a mutable boolean property used to control whether MetaMask reloaded the page on chain/network changes.\nHowever, it only caused the page to be reloaded if the a script access a property on `window.web3`.\nTherefore, this property was removed along with `window.web3`.\n\nDespite this, we still recommend reloading the page on chain changes.\nSome convenience libraries, such as [ethers](https://www.npmjs.com/package/ethers), will continue to reload the page by default.\nIf you don't use such a convenience library, you'll have to reload the page manually.\nPlease see the [`chainChanged` event](./ethereum-provider.html#chainchanged) for details.","metadata":{"source":"provider-migration"}}],["225",{"pageContent":"# Patching Dependencies\n\n::: tip Only Available in MetaMask Flask\n[Snaps](./snaps.html) is only available in [MetaMask Flask](https://metamask.io/flask).\n:::\n\nA problem that may arise as you develop your snap is that some dependencies make use of APIs that aren't available in the snaps execution environment. To work around this, we firstly recommend that you check if another library is available that makes use of the APIs made available for snaps (see [Snaps Development Guide](./snaps-development-guide.html#the-snap-execution-environment) for a list of APIs).\n\nIf you are unable to find another library (or version) that works with the snaps execution environment, another way of solving the problem is by patching the dependency yourself. For this we can leverage [`patch-package`](https://npmjs.com/package/patch-package).\n\n`patch-package` works by allowing you to make changes to your dependencies, saving the changes as a patch and replaying it when installing dependencies.","metadata":{"source":"snaps-patching-dependencies"}}],["226",{"pageContent":"`patch-package` works by allowing you to make changes to your dependencies, saving the changes as a patch and replaying it when installing dependencies.\n\nTo use it, install it using the following command:\n\n`yarn add -D patch-package postinstall-postinstall`.\n\nThen add a postinstall script to your `package.json`.\n\n```diff\n \"scripts\": {\n+  \"postinstall\": \"patch-package\"\n }","metadata":{"source":"snaps-patching-dependencies"}}],["227",{"pageContent":"Now you can make changes to your dependencies inside `node_modules` and run `yarn patch-package package-name` to save the changes as a patch. This will create a `.patch` file containing your dependency patch. These patches can be committed to your Git repository and will be replayed when you re-install your dependencies.\n\n**If you need guidance in how you can patch your dependencies or otherwise need help troubleshooting dependency problems, please create an issue on the [MetaMask/snaps-monorepo](https://github.com/MetaMask/snaps-monorepo) repository.**","metadata":{"source":"snaps-patching-dependencies"}}],["228",{"pageContent":"Patching the use of XMLHttpRequest\n\nThe `XMLHttpRequest` API is not exposed in the snaps execution environment and will not be in the future. Because of this, you may run into issues with dependencies in your dependency tree attempting to leverage this API for their network requests.\n\nBelow we've included some examples of popular libraries that use `XMLHttpRequest` and are therefore not compatible with the snaps execution environment. Below you'll also find some patching strategies for fixing dependencies that try to make use of these libraries.","metadata":{"source":"snaps-patching-dependencies"}}],["229",{"pageContent":"cross-fetch\n\n`cross-fetch` is a popular library used for cross-platform access to the `fetch` API across multiple environments. Under the hood, however, the library does make use of `XMLHttpRequest` and therefore it will cause issues when used in a snap.\n\nLuckily, this issue is fairly easy to patch with `patch-package`. To do this, open up `node_modules/cross-fetch/browser-ponyfill.js` and find the following lines (it's close to the bottom):\n\n```javascript\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\n```\n\nYou can replace that with the following snippet:\n\n```javascript\n// Choose between native implementation (global) or custom implementation (__self__)\nvar ctx = global.fetch\n  ? { ...global, fetch: global.fetch.bind(global) }\n  : __self__;\n// var ctx = __self__; // this line disable service worker support temporarily","metadata":{"source":"snaps-patching-dependencies"}}],["230",{"pageContent":"After replacing it, run `yarn patch-package cross-fetch` which saves the patch for future use.\n\nIf you find that it's easier you can also use the following patch, copy and paste this to `patches/cross-fetch+3.1.5.patch` and re-install your dependencies.","metadata":{"source":"snaps-patching-dependencies"}}],["231",{"pageContent":"```diff\ndiff --git a/node_modules/cross-fetch/dist/browser-ponyfill.js b/node_modules/cross-fetch/dist/browser-ponyfill.js\nindex f216aa3..6b3263b 100644\n--- a/node_modules/cross-fetch/dist/browser-ponyfill.js\n+++ b/node_modules/cross-fetch/dist/browser-ponyfill.js\n@@ -543,8 +543,8 @@ __self__.fetch.ponyfill = true;\n // Remove \"polyfill\" property added by whatwg-fetch\n delete __self__.fetch.polyfill;\n // Choose between native implementation (global) or custom implementation (__self__)\n-// var ctx = global.fetch ? global : __self__;\n-var ctx = __self__; // this line disable service worker support temporarily\n+var ctx = global.fetch ? { ...global, fetch: global.fetch.bind(global) } : __self__;\n+// var ctx = __self__; // this line disable service worker support temporarily\n exports = ctx.fetch // To enable: import fetch from 'cross-fetch'\n exports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\n exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'","metadata":{"source":"snaps-patching-dependencies"}}],["232",{"pageContent":"Using either of these methods allows your dependencies to access the `fetch` API correctly and `cross-fetch` compatible with the snaps execution environment.","metadata":{"source":"snaps-patching-dependencies"}}],["233",{"pageContent":"axios\n\n`axios` is another popular networking library that leverages `XMLHttpRequest` under the hood.\n\nAt the time of writing there is no known way of patching `axios` to work with the snaps execution environment. Instead you may have to resort to replacing the usage of `axios` with another library such as `isomorphic-fetch` or `isomorphic-unfetch`. Or simply using the snaps execution environment global `fetch`.\n\nBelow is a small example of how you can rewrite your dependency to use `fetch` instead of `axios`.\n**Note**: In a production environment this may be a large task depending on the usage of `axios`.\n\n**axios**\n\n```javascript\nconst instance = axios.create({\n  baseURL: 'https://api.github.com/',\n});\n\ninstance\n  .get('users/MetaMask')\n  .then((res) => {\n    if (res.status >= 400) {\n      throw new Error('Bad response from server');\n    }\n    return res.data;\n  })\n  .then((user) => {\n    console.log(user);\n  })\n  .catch((err) => {\n    console.error(err);\n  });","metadata":{"source":"snaps-patching-dependencies"}}],["234",{"pageContent":"**fetch**\n\n```javascript\nfetch('https://api.github.com/users/MetaMask')\n  .then((res) => {\n    if (!res.ok) {\n      throw new Error('Bad response from server');\n    }\n    return res.json();\n  })\n  .then((json) => console.log(json))\n  .catch((err) => console.error(err));\n```\n\nMore resources:\n\n- [Replace axios with a simple custom fetch wrapper](https://kentcdodds.com/blog/replace-axios-with-a-simple-custom-fetch-wrapper)","metadata":{"source":"snaps-patching-dependencies"}}],["235",{"pageContent":"# Ethereum Provider API\n\n::: tip Recommended Reading\nWe recommend that all web3 site developers read the [Basic Usage](#basic-usage) section.\n:::\n\n::: tip Recent Breaking Provider Changes\nIf you are an Ethereum application developer and are looking for information about our January 2021 provider API changes,\nplease see our [Migration Guide](./provider-migration.html) for more details.\n:::\n\nMetaMask injects a global API into websites visited by its users at `window.ethereum`.\nThis API allows websites to request users' Ethereum accounts, read data from blockchains the user is connected to, and suggest that the user sign messages and transactions.\nThe presence of the provider object indicates an Ethereum user.\nWe recommend using [`@metamask/detect-provider`](https://npmjs.com/package/@metamask/detect-provider) to detect our provider, on any platform or browser.\n\nThe Ethereum JavaScript provider API is specified by [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193).","metadata":{"source":"ethereum-provider"}}],["236",{"pageContent":"The Ethereum JavaScript provider API is specified by [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193).\n\n```javascript\n// This function detects most providers injected at window.ethereum\nimport detectEthereumProvider from '@metamask/detect-provider';\n\nconst provider = await detectEthereumProvider();\n\nif (provider) {\n  // From now on, this should always be true:\n  // provider === window.ethereum\n  startApp(provider); // initialize your app\n} else {\n  console.log('Please install MetaMask!');\n}\n```","metadata":{"source":"ethereum-provider"}}],["237",{"pageContent":"Table of Contents\n\n[[toc]]\n\n## Basic Usage\n\nFor any non-trivial Ethereum web application — a.k.a. dapp, web3 site etc. — to work, you will have to:\n\n- Detect the Ethereum provider (`window.ethereum`)\n- Detect which Ethereum network the user is connected to\n- Get the user's Ethereum account(s)\n\nThe snippet at the top of this page is sufficient for detecting the provider.\nYou can learn how to accomplish the other two by reviewing the snippet in the [Using the Provider section](#using-the-provider).\n\nThe provider API is all you need to create a full-featured web3 application.\n\nThat said, many developers use a convenience library, such as [ethers](https://www.npmjs.com/package/ethers), instead of using the provider directly.\nIf you are in need of higher-level abstractions than those provided by this API, we recommend that you use a convenience library.","metadata":{"source":"ethereum-provider"}}],["238",{"pageContent":"Chain IDs\n\nThese are the IDs of the Ethereum chains that MetaMask supports by default.\nConsult [chainid.network](https://chainid.network) for more.\n\n| Hex  | Decimal | Network                         |\n| ---- | ------- | ------------------------------- |\n| 0x1  | 1       | Ethereum Main Network (Mainnet) |\n| 0x3  | 3       | Ropsten Test Network            |\n| 0x4  | 4       | Rinkeby Test Network            |\n| 0x5  | 5       | Goerli Test Network             |\n| 0x2a | 42      | Kovan Test Network              |\n\n## Properties\n\n### ethereum.isMetaMask\n\n::: warning Note\nThis property is non-standard. Non-MetaMask providers may also set this property to `true`.\n:::\n\n`true` if the user has MetaMask installed.","metadata":{"source":"ethereum-provider"}}],["239",{"pageContent":"Methods\n\n### ethereum.isConnected()\n\n::: tip Tip\nNote that this method has nothing to do with the user's accounts.\n\nYou may often encounter the word \"connected\" in reference to whether a web3 site can access the user's accounts.\nIn the provider interface, however, \"connected\" and \"disconnected\" refer to whether the provider can make RPC requests to the current chain.\n:::\n\n```typescript\nethereum.isConnected(): boolean;\n```\n\nReturns `true` if the provider is connected to the current chain, and `false` otherwise.\n\nIf the provider is not connected, the page will have to be reloaded in order for connection to be re-established.\nPlease see the [`connect`](#connect) and [`disconnect`](#disconnect) events for more information.","metadata":{"source":"ethereum-provider"}}],["240",{"pageContent":"ethereum.request(args)\n\n```typescript\ninterface RequestArguments {\n  method: string;\n  params?: unknown[] | object;\n}\n\nethereum.request(args: RequestArguments): Promise<unknown>;\n```\n\nUse `request` to submit RPC requests to Ethereum via MetaMask.\nIt returns a `Promise` that resolves to the result of the RPC method call.\n\nThe `params` and return value will vary by RPC method.\nIn practice, if a method has any `params`, they are almost always of type `Array<any>`.\n\nIf the request fails for any reason, the Promise will reject with an [Ethereum RPC Error](#errors).\n\nMetaMask supports most standardized Ethereum RPC methods, in addition to a number of methods that may not be\nsupported by other wallets.\nSee the MetaMask [RPC API documentation](./rpc-api.html) for details.","metadata":{"source":"ethereum-provider"}}],["241",{"pageContent":"Example\n\n```javascript\nparams: [\n  {\n    from: '0xb60e8dd61c5d32be8058bb8eb970870f07233155',\n    to: '0xd46e8dd67c5d32be8058bb8eb970870f07244567',\n    gas: '0x76c0', // 30400\n    gasPrice: '0x9184e72a000', // 10000000000000\n    value: '0x9184e72a', // 2441406250\n    data:\n      '0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675',\n  },\n];\n\nethereum\n  .request({\n    method: 'eth_sendTransaction',\n    params,\n  })\n  .then((result) => {\n    // The result varies by RPC method.\n    // For example, this method will return a transaction hash hexadecimal string on success.\n  })\n  .catch((error) => {\n    // If the request fails, the Promise will reject with an error.\n  });\n```","metadata":{"source":"ethereum-provider"}}],["242",{"pageContent":"Events\n\nThe MetaMask provider implements the [Node.js `EventEmitter`](https://nodejs.org/api/events.html) API.\nThis sections details the events emitted via that API.\nThere are innumerable `EventEmitter` guides elsewhere, but you can listen for events like this:\n\n```javascript\nethereum.on('accountsChanged', (accounts) => {\n  // Handle the new accounts, or lack thereof.\n  // \"accounts\" will always be an array, but it can be empty.\n});\n\nethereum.on('chainChanged', (chainId) => {\n  // Handle the new chain.\n  // Correctly handling chain changes can be complicated.\n  // We recommend reloading the page unless you have good reason not to.\n  window.location.reload();\n});\n```\n\nAlso, don't forget to remove listeners once you are done listening to them (for example on component unmount in React):\n\n```javascript\nfunction handleAccountsChanged(accounts) {\n  // ...\n}\n\nethereum.on('accountsChanged', handleAccountsChanged);\n\n// Later\n\nethereum.removeListener('accountsChanged', handleAccountsChanged);","metadata":{"source":"ethereum-provider"}}],["243",{"pageContent":"The first argument of the `ethereum.removeListener` is the event name and the second argument is the reference to the same function which has passed to `ethereum.on` for the event name mentioned in the first argument.","metadata":{"source":"ethereum-provider"}}],["244",{"pageContent":"connect\n\n```typescript\ninterface ConnectInfo {\n  chainId: string;\n}\n\nethereum.on('connect', handler: (connectInfo: ConnectInfo) => void);\n```\n\nThe MetaMask provider emits this event when it first becomes able to submit RPC requests to a chain.\nWe recommend using a `connect` event handler and the [`ethereum.isConnected()` method](#ethereum-isconnected) in order to determine when/if the provider is connected.","metadata":{"source":"ethereum-provider"}}],["245",{"pageContent":"disconnect\n\n```typescript\nethereum.on('disconnect', handler: (error: ProviderRpcError) => void);\n```\n\nThe MetaMask provider emits this event if it becomes unable to submit RPC requests to any chain.\nIn general, this will only happen due to network connectivity issues or some unforeseen error.\n\nOnce `disconnect` has been emitted, the provider will not accept any new requests until the connection to the chain has been re-established, which requires reloading the page.\nYou can also use the [`ethereum.isConnected()` method](#ethereum-isconnected) to determine if the provider is disconnected.","metadata":{"source":"ethereum-provider"}}],["246",{"pageContent":"accountsChanged\n\n```typescript\nethereum.on('accountsChanged', handler: (accounts: Array<string>) => void);\n```\n\nThe MetaMask provider emits this event whenever the return value of the `eth_accounts` RPC method changes.\n`eth_accounts` returns an array that is either empty or contains a single account address.\nThe returned address, if any, is the address of the most recently used account that the caller is permitted to access.\nCallers are identified by their URL _origin_, which means that all sites with the same origin share the same permissions.\n\nThis means that `accountsChanged` will be emitted whenever the user's exposed account address changes.\n\n::: tip Tip\nWe plan to allow the `eth_accounts` array to be able to contain multiple addresses in the near future.\n:::","metadata":{"source":"ethereum-provider"}}],["247",{"pageContent":"chainChanged\n\n::: tip Tip\nSee the [Chain IDs section](#chain-ids) for MetaMask's default chains and their chain IDs.\n:::\n\n```typescript\nethereum.on('chainChanged', handler: (chainId: string) => void);\n```\n\nThe MetaMask provider emits this event when the currently connected chain changes.\n\nAll RPC requests are submitted to the currently connected chain.\nTherefore, it's critical to keep track of the current chain ID by listening for this event.\n\nWe _strongly_ recommend reloading the page on chain changes, unless you have good reason not to.\n\n```javascript\nethereum.on('chainChanged', (_chainId) => window.location.reload());\n```","metadata":{"source":"ethereum-provider"}}],["248",{"pageContent":"message\n\n```typescript\ninterface ProviderMessage {\n  type: string;\n  data: unknown;\n}\n\nethereum.on('message', handler: (message: ProviderMessage) => void);\n```\n\nThe MetaMask provider emits this event when it receives some message that the consumer should be notified of.\nThe kind of message is identified by the `type` string.\n\nRPC subscription updates are a common use case for the `message` event.\nFor example, if you create a subscription using `eth_subscribe`, each subscription update will be emitted as a `message` event with a `type` of `eth_subscription`.","metadata":{"source":"ethereum-provider"}}],["249",{"pageContent":"Errors\n\nAll errors thrown or returned by the MetaMask provider follow this interface:\n\n```typescript\ninterface ProviderRpcError extends Error {\n  message: string;\n  code: number;\n  data?: unknown;\n}\n```\n\nThe [`ethereum.request(args)` method](#ethereum-request-args) throws errors eagerly.\nYou can often use the error `code` property to determine why the request failed.\nCommon codes and their meaning include:\n\n- `4001`\n  - The request was rejected by the user\n- `-32602`\n  - The parameters were invalid\n- `-32603`\n  - Internal error\n\nFor the complete list of errors, please see [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193#provider-errors) and [EIP-1474](https://eips.ethereum.org/EIPS/eip-1474#error-codes).\n\n::: tip Tip\nThe [`eth-rpc-errors`](https://npmjs.com/package/eth-rpc-errors) package implements all RPC errors thrown by the MetaMask provider, and can help you identify their meaning.\n:::","metadata":{"source":"ethereum-provider"}}],["250",{"pageContent":"Using the Provider\n\nThis snippet explains how to accomplish the three most common requirements for web3 sites:\n\n- Detect the Ethereum provider (`window.ethereum`)\n- Detect which Ethereum network the user is connected to\n- Get the user's Ethereum account(s)\n\n<<< @/docs/snippets/handleProvider.js\n\n## Experimental API\n\n::: warning\nThere is no guarantee that the methods and properties defined in this section will remain stable.\nUse it at your own risk.\n:::\n\nWe expose some experimental, MetaMask-specific methods under the `ethereum._metamask` property.\n\n## Experimental Methods\n\n### ethereum.\\_metamask.isUnlocked()\n\n```typescript\nethereum._metamask.isUnlocked(): Promise<boolean>;\n```\n\nThis method returns a `Promise` that resolves to a `boolean` indicating if MetaMask is unlocked by the user.\nMetaMask must be unlocked in order to perform any operation involving user accounts.\nNote that this method does not indicate if the user has exposed any accounts to the caller.","metadata":{"source":"ethereum-provider"}}],["251",{"pageContent":"Legacy API\n\n::: warning\nYou should **never** rely on any of these methods, properties, or events in practice.\n:::\n\nThis section documents our legacy provider API.\nMetaMask only supported this API before the provider API was standardized via [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) in 2020.\nBecause of this, you may find web3 sites that use this API, or other providers that implement it.","metadata":{"source":"ethereum-provider"}}],["252",{"pageContent":"Legacy Properties\n\n### ethereum.chainId (DEPRECATED)\n\n::: warning\nThis property is non-standard, and therefore deprecated.\n\nIf you need to retrieve the current chain ID, use [`ethereum.request({ method: 'eth_chainId' })`](#ethereum-request-args).\nSee also the [`chainChanged`](#chainchanged) event for more information about how to handle chain IDs.\n\nThe value of this property can change at any time.\n:::\n\nA hexadecimal string representing the current chain ID.\n\n### ethereum.networkVersion (DEPRECATED)\n\n::: warning\nYou should always prefer the chain ID over the network ID.\n\nIf you must get the network ID, use [`ethereum.request({ method: 'net_version' })`](#ethereum-request-args).\n\nThe value of this property can change at any time.\n:::\n\nA decimal string representing the current blockchain's network ID.","metadata":{"source":"ethereum-provider"}}],["253",{"pageContent":"ethereum.selectedAddress (DEPRECATED)\n\n::: warning\nUse [`ethereum.request({ method: 'eth_accounts' })`](#ethereum-request-args) instead.\n\nThe value of this property can change at any time.\n:::\n\nReturns a hexadecimal string representing the user's \"currently selected\" address.\n\nThe \"currently selected\" address is the first item in the array returned by `eth_accounts`.","metadata":{"source":"ethereum-provider"}}],["254",{"pageContent":"Legacy Methods\n\n### ethereum.enable() (DEPRECATED)\n\n::: warning\nUse [`ethereum.request({ method: 'eth_requestAccounts' })`](#ethereum-request-args) instead.\n:::\n\nAlias for `ethereum.request({ method: 'eth_requestAccounts' })`.","metadata":{"source":"ethereum-provider"}}],["255",{"pageContent":"ethereum.sendAsync() (DEPRECATED)\n\n::: warning\nUse [`ethereum.request()`](#ethereum-request-args) instead.\n:::\n\n```typescript\ninterface JsonRpcRequest {\n  id: string | undefined;\n  jsonrpc: '2.0';\n  method: string;\n  params?: Array<any>;\n}\n\ninterface JsonRpcResponse {\n  id: string | undefined;\n  jsonrpc: '2.0';\n  method: string;\n  result?: unknown;\n  error?: Error;\n}\n\ntype JsonRpcCallback = (error: Error, response: JsonRpcResponse) => unknown;\n\nethereum.sendAsync(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n```\n\nThis is the ancestor of `ethereum.request`. It only works for JSON-RPC methods, and takes a JSON-RPC request payload object and an error-first callback function as its arguments.\n\nSee the [Ethereum JSON-RPC API](https://eips.ethereum.org/EIPS/eip-1474) for details.","metadata":{"source":"ethereum-provider"}}],["256",{"pageContent":"ethereum.send() (DEPRECATED)\n\n::: warning\nUse [`ethereum.request()`](#ethereum-request-args) instead.\n:::\n\n```typescript\nethereum.send(\n  methodOrPayload: string | JsonRpcRequest,\n  paramsOrCallback: Array<unknown> | JsonRpcCallback,\n): Promise<JsonRpcResponse> | void;\n```\n\nThis method behaves unpredictably and should be avoided at all costs.\nIt is essentially an overloaded version of [`ethereum.sendAsync()`](#ethereum-sendasync-deprecated).\n\n`ethereum.send()` can be called in three different ways:\n\n```typescript\n// 1.\nethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n\n// 2.\nethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n\n// 3.\nethereum.send(payload: JsonRpcRequest): unknown;","metadata":{"source":"ethereum-provider"}}],["257",{"pageContent":"You can think of these signatures as follows:\n\n1. This signature is exactly like `ethereum.sendAsync()`\n\n2. This signature is like an async `ethereum.sendAsync()` with `method` and `params` as arguments, instead of a JSON-RPC payload and callback\n\n3. This signature enables you to call the following RPC methods synchronously:\n\n   - `eth_accounts`\n   - `eth_coinbase`\n   - `eth_uninstallFilter`\n   - `net_version`","metadata":{"source":"ethereum-provider"}}],["258",{"pageContent":"Legacy Events\n\n### close (DEPRECATED)\n\n::: warning\nUse [`disconnect`](#disconnect) instead.\n:::\n\n```typescript\nethereum.on('close', handler: (error: Error) => void);\n```\n\n### chainIdChanged (DEPRECATED)\n\n::: warning\nUse [`chainChanged`](#chainchanged) instead.\n:::\n\nMisspelled alias of [`chainChanged`](#chainchanged).\n\n```typescript\nethereum.on('chainChanged', handler: (chainId: string) => void);\n```\n\n### networkChanged (DEPRECATED)\n\n::: warning\nUse [`chainChanged`](#chainchanged) instead.\n:::\n\nLike [`chainChanged`](#chainchanged), but with the `networkId` instead.\nNetwork IDs are insecure, and were effectively deprecated in favor of chain IDs by [EIP-155](https://eips.ethereum.org/EIPS/eip-155).\nAvoid using them unless you know what you are doing.\n\n```typescript\nethereum.on('networkChanged', handler: (networkId: string) => void);\n```\n\n### notification (DEPRECATED)\n\n::: warning\nUse [`message`](#message) instead.\n:::\n\n```typescript\nethereum.on('notification', handler: (payload: any) => void);\n```","metadata":{"source":"ethereum-provider"}}],["259",{"pageContent":"# Create A Simple Dapp\n\n::: tip Tip\nWe will be building this [app](https://metamask.github.io/test-dapp/)\n:::","metadata":{"source":"create-dapp"}}],["260",{"pageContent":"Project Setup\n\nBefore you set up make sure you've visited and gone through our [Getting Started Guide](./getting-started.html#getting-started)\n\nMake sure you have:\n\n1. The [MetaMask Extension](https://metamask.io/download.html) downloaded.\n2. Node.js [Downloaded and Installed](https://nodejs.org/)\n3. Clone/Download the [Project Files](https://github.com/BboyAkers/simple-dapp-tutorial) from GitHub.\n4. Your favorite Text Editor or IDE installed. I personally like [Visual Studio Code](https://code.visualstudio.com/)\n\n### Open Project Folder\n\nOpen the project folder. Navigate to `start`->`index.html`, and look at the comment stating part 1. This is the UI for the Simple Dapp with all of the layout and buttons that will help us learn the basics of connecting to our MetaMask extension. We will be using/building off of this entire section for the first part of the tutorial.","metadata":{"source":"create-dapp"}}],["261",{"pageContent":"Install Dependencies\n\nOpen a terminal and make sure your terminal is inside the base directory of the `start/` folder. Inside the folder, the files should look like this:\n\n```\n.\n├─ index.html\n├─ contract.js\n├─ metamask.css\n├─ package.json\n└─ README.md\n```\n\nYou'll have some more files but that's nothing to worry about!\n\nOpen your terminal and navigate into the start folder. In this folder run:\n\n```bash\nyarn install\n```\n\nThis will install all the necessary dependencies we'll need for our project. This will have created a `node_modules/` folder where all the dependencies are stored.\n\nNext run:\n\n```bash\nyarn run serve\n```\n\nNavigate to [`http://localhost:9011`](http://localhost:9011)","metadata":{"source":"create-dapp"}}],["262",{"pageContent":"Basic Action(Part 1)\n\nNow let's navigate into the contract.js file inside your start folder.\n\nYour file should look something like this. Don't worry about lines 1-31.\n\n```javascript\nconst forwarderOrigin = 'http://localhost:9010';\n\nconst initialize = () => {\n  //You will start here\n};\nwindow.addEventListener('DOMContentLoaded', initialize);\n```\n\nAs soon as the content in the DOM is loaded we are calling our initialize function. Now before we start writing any code let's look at our task list for the first part of this app.\n\nWhat we'll cover in part one:\n\n- [Connecting to the MetaMask Wallet](./create-dapp.html#connecting-to-the-metamask-wallet)\n- See our eth_accounts result\n- Display our network number\n- Display our ChainId\n- Display our Accounts","metadata":{"source":"create-dapp"}}],["263",{"pageContent":"Connecting to the MetaMask Wallet\n\nThe first thing we need to do in our Dapp is to connect to our MetaMask Wallet.\n\n1. We need to create a function to see if the MetaMask Chrome extension is installed\n2. If MetaMask is not installed we:\n   1. Change our `connectButton` to `Click here to install MetaMask`\n   2. When clicking that button it should take us to a page that will allow us to install the extension\n   3. Disable the button\n3. If MetaMask is installed we:\n   1. Change our `connectButton` to `Connect`\n   2. When clicking that button it should allow us to connect to our MetaMask wallet\n   3. Disable the button\n\nLet's get to it!!","metadata":{"source":"create-dapp"}}],["264",{"pageContent":"MetaMask Extension Check\n\nIn our code we need to connect to our button from our index.html\n\n```javascript\nconst initialize = () => {\n  //Basic Actions Section\n  const onboardButton = document.getElementById('connectButton');\n};\n```\n\nNext we create a check function called `isMetaMaskInstalled` to see if the MetaMask extension is installed\n\n```javascript\nconst initialize = () => {\n  //Basic Actions Section\n  const onboardButton = document.getElementById('connectButton');\n\n  //Created check function to see if the MetaMask extension is installed\n  const isMetaMaskInstalled = () => {\n    //Have to check the ethereum binding on the window object to see if it's installed\n    const { ethereum } = window;\n    return Boolean(ethereum && ethereum.isMetaMask);\n  };\n};","metadata":{"source":"create-dapp"}}],["265",{"pageContent":"Next we need to create a `MetaMaskClientCheck` function to see if we need to change the button text based on if the MetaMask Extension is installed or not.\n\n```javascript\nconst initialize = () => {\n  //Basic Actions Section\n  const onboardButton = document.getElementById('connectButton');\n\n  //Created check function to see if the MetaMask extension is installed\n  const isMetaMaskInstalled = () => {\n    //Have to check the ethereum binding on the window object to see if it's installed\n    const { ethereum } = window;\n    return Boolean(ethereum && ethereum.isMetaMask);\n  };","metadata":{"source":"create-dapp"}}],["266",{"pageContent":"//------Inserted Code------\\\\\n  const MetaMaskClientCheck = () => {\n    //Now we check to see if MetaMask is installed\n    if (!isMetaMaskInstalled()) {\n      //If it isn't installed we ask the user to click to install it\n      onboardButton.innerText = 'Click here to install MetaMask!';\n    } else {\n      //If it is installed we change our button text\n      onboardButton.innerText = 'Connect';\n    }\n  };\n  MetaMaskClientCheck();\n  //------/Inserted Code------\\\\\n};\n```","metadata":{"source":"create-dapp"}}],["267",{"pageContent":"MetaMask \"Not Installed\" Dapp Flow\n\nIn our code block where MetaMask isn't installed and we ask the user to `'Click here to install MetaMask!'`, we need to ensure that if our button is clicked we:\n\n1. Redirect the user to the proper page to install the extension\n2. Disable the button\n\n```javascript\nconst MetaMaskClientCheck = () => {\n  //Now we check to see if Metmask is installed\n  if (!isMetaMaskInstalled()) {\n    //If it isn't installed we ask the user to click to install it\n    onboardButton.innerText = 'Click here to install MetaMask!';\n    //When the button is clicked we call this function\n    onboardButton.onclick = onClickInstall;\n    //The button is now disabled\n    onboardButton.disabled = true;\n  } else {\n    //If it is installed we change our button text\n    onboardButton.innerText = 'Connect';\n  }\n};\nMetaMaskClientCheck();","metadata":{"source":"create-dapp"}}],["268",{"pageContent":"We've created a function that will be called when we click the button and disable it. Let's dive into the `onClickInstall` function and create the logic inside of it.\n\n::: tip Tip\nFor this part we will be using the '@metamask/onboarding' library we installed during the npm install. To learn more visit [here](https://github.com/MetaMask/metamask-onboarding#metamask-onboarding)\n:::\nInside this function we want to:\n\n1. Change the text of the button to `Onboarding in progress`\n2. Disable the button\n3. Start the onboarding process\n\nAbove your `MetaMaskClientCheck` function write/insert this code.\n\n```javascript\n//We create a new MetaMask onboarding object to use in our app\nconst onboarding = new MetaMaskOnboarding({ forwarderOrigin });","metadata":{"source":"create-dapp"}}],["269",{"pageContent":"```javascript\n//We create a new MetaMask onboarding object to use in our app\nconst onboarding = new MetaMaskOnboarding({ forwarderOrigin });\n\n//This will start the onboarding proccess\nconst onClickInstall = () => {\n  onboardButton.innerText = 'Onboarding in progress';\n  onboardButton.disabled = true;\n  //On this object we have startOnboarding which will start the onboarding process for our end user\n  onboarding.startOnboarding();\n};","metadata":{"source":"create-dapp"}}],["270",{"pageContent":"GREAT! Now if our end user doesn't have the MetaMask Extension they can install it. When they refresh the page the ethereum window object will be there and we can get on to connecting their MetaMask wallet to our Dapp!","metadata":{"source":"create-dapp"}}],["271",{"pageContent":"MetaMask \"Installed\" Dapp Flow\n\nNext we need to revisit our `MetaMaskClientCheck` function and create similar functionality that we did in our \"MetaMask Not Installed\" block in our \"MetaMask Is Installed\" block of code.","metadata":{"source":"create-dapp"}}],["272",{"pageContent":"Next we need to revisit our `MetaMaskClientCheck` function and create similar functionality that we did in our \"MetaMask Not Installed\" block in our \"MetaMask Is Installed\" block of code.\n\n```javascript\nconst MetaMaskClientCheck = () => {\n  //Now we check to see if Metmask is installed\n  if (!isMetaMaskInstalled()) {\n    //If it isn't installed we ask the user to click to install it\n    onboardButton.innerText = 'Click here to install MetaMask!';\n    //When the button is clicked we call th is function\n    onboardButton.onclick = onClickInstall;\n    //The button is now disabled\n    onboardButton.disabled = true;\n  } else {\n    //If MetaMask is installed we ask the user to connect to their wallet\n    onboardButton.innerText = 'Connect';\n    //When the button is clicked we call this function to connect the users MetaMask Wallet\n    onboardButton.onclick = onClickConnect;\n    //The button is now enabled\n    onboardButton.disabled = false;\n  }\n};\nMetaMaskClientCheck();","metadata":{"source":"create-dapp"}}],["273",{"pageContent":"Now we've created a function that will be called whenever we click the button to trigger a connection to our wallet, disabling the button. Next, let's dive into the `onClickConnect` function and build the logic we need inside of it.\n\nInside this function we want to:\n\n1. Create an async function that will try to call the 'eth_requestAccounts' RPC method\n2. Catch any errors and log them to the console\n\nUnder your `onClickInstall` function write/insert this code.\n\n```javascript\nconst onClickConnect = async () => {\n  try {\n    // Will open the MetaMask UI\n    // You should disable this button while the request is pending!\n    await ethereum.request({ method: 'eth_requestAccounts' });\n  } catch (error) {\n    console.error(error);\n  }\n};\n```\n\nGreat! Now once you click the button the MetaMask Extension will pop up and connect your wallet.","metadata":{"source":"create-dapp"}}],["274",{"pageContent":"Get Ethereum Accounts\n\nAfter this what we'd like to do next is whenever we press the `eth_accounts` button we'd like to get our Ethereum account and display it. Replace the existing `const onboardButton` at the top of the `initialize()` function with the following three buttons:\n\n```javascript\n//Basic Actions Section\nconst onboardButton = document.getElementById('connectButton');\nconst getAccountsButton = document.getElementById('getAccounts');\nconst getAccountsResult = document.getElementById('getAccountsResult');","metadata":{"source":"create-dapp"}}],["275",{"pageContent":"Now that we've grabbed our eth_accounts button and our paragraph field to display it in we now have to grab the data.\n\nUnder our `MetaMaskClientCheck()` function let's write/insert the code below.\n\n```javascript\n//Eth_Accounts-getAccountsButton\ngetAccountsButton.addEventListener('click', async () => {\n  //we use eth_accounts because it returns a list of addresses owned by us.\n  const accounts = await ethereum.request({ method: 'eth_accounts' });\n  //We take the first address in the array of addresses and display it\n  getAccountsResult.innerHTML = accounts[0] || 'Not able to get accounts';\n});","metadata":{"source":"create-dapp"}}],["276",{"pageContent":"If you have already connected to your wallet in the previous section of the tutorial, you can go into MetaMask's \"Connected Sites\" menu and remove the localhost connection. This will enable us to test both buttons again. If we refresh our page, and click the \"ETH_ACCOUNTS\" button, we should see `'eth_accounts result: Not able to get accounts'`.\n\nLet's go ahead and press the \"Connect\" button again, and confirm the \"Connect With MetaMask\" prompt and \"Connect\". Now we can click the \"ETH_ACCOUNTS\" button again and we should see our MetaMask account public address.\n\n**CONGRATULATIONS!**\n\nWe have just completed building out our Basic Actions functionality. You know how to Connect to MetaMask, see your connected apps and remove them, as well as retrieve accounts.\n\nNow on to our next step, showing our statuses.\n\nPreview of the completed code up until this point of the tutorial:\n\n```javascript\nconst forwarderOrigin = 'http://localhost:9010';","metadata":{"source":"create-dapp"}}],["277",{"pageContent":"Now on to our next step, showing our statuses.\n\nPreview of the completed code up until this point of the tutorial:\n\n```javascript\nconst forwarderOrigin = 'http://localhost:9010';\n\nconst initialize = () => {\n  //Basic Actions Section\n  const onboardButton = document.getElementById('connectButton');\n  const getAccountsButton = document.getElementById('getAccounts');\n  const getAccountsResult = document.getElementById('getAccountsResult');\n\n  //Created check function to see if the MetaMask extension is installed\n  const isMetaMaskInstalled = () => {\n    //Have to check the ethereum binding on the window object to see if it's installed\n    const { ethereum } = window;\n    return Boolean(ethereum && ethereum.isMetaMask);\n  };\n\n  //We create a new MetaMask onboarding object to use in our app\n  const onboarding = new MetaMaskOnboarding({ forwarderOrigin });","metadata":{"source":"create-dapp"}}],["278",{"pageContent":"//We create a new MetaMask onboarding object to use in our app\n  const onboarding = new MetaMaskOnboarding({ forwarderOrigin });\n\n  //This will start the onboarding proccess\n  const onClickInstall = () => {\n    onboardButton.innerText = 'Onboarding in progress';\n    onboardButton.disabled = true;\n    //On this object we have startOnboarding which will start the onboarding process for our end user\n    onboarding.startOnboarding();\n  };\n\n  const onClickConnect = async () => {\n    try {\n      // Will open the MetaMask UI\n      // You should disable this button while the request is pending!\n      await ethereum.request({ method: 'eth_requestAccounts' });\n    } catch (error) {\n      console.error(error);\n    }\n  };","metadata":{"source":"create-dapp"}}],["279",{"pageContent":"const MetaMaskClientCheck = () => {\n    //Now we check to see if Metmask is installed\n    if (!isMetaMaskInstalled()) {\n      //If it isn't installed we ask the user to click to install it\n      onboardButton.innerText = 'Click here to install MetaMask!';\n      //When the button is clicked we call th is function\n      onboardButton.onclick = onClickInstall;\n      //The button is now disabled\n      onboardButton.disabled = false;\n    } else {\n      //If MetaMask is installed we ask the user to connect to their wallet\n      onboardButton.innerText = 'Connect';\n      //When the button is clicked we call this function to connect the users MetaMask Wallet\n      onboardButton.onclick = onClickConnect;\n      //The button is now disabled\n      onboardButton.disabled = false;\n    }\n  };","metadata":{"source":"create-dapp"}}],["280",{"pageContent":"//Eth_Accounts-getAccountsButton\n  getAccountsButton.addEventListener('click', async () => {\n    //we use eth_accounts because it returns a list of addresses owned by us.\n    const accounts = await ethereum.request({ method: 'eth_accounts' });\n    //We take the first address in the array of addresses and display it\n    getAccountsResult.innerHTML = accounts[0] || 'Not able to get accounts';\n  });\n\n  MetaMaskClientCheck();\n};\n\nwindow.addEventListener('DOMContentLoaded', initialize);\n```","metadata":{"source":"create-dapp"}}],["281",{"pageContent":"# Signing Data\n\nMetaMask lets you request cryptographic signatures from users in a number of ways.\n\n- [eth_signTypedData_v4](#signtypeddata-v4) for the most readable signatures that are also efficient to process on chain.\n- [personal_sign](#personal-sign) for the easiest way to get a human readable signature of data that does not need to be efficiently processed on-chain.\n- `eth_sign` (deprecated) By default MetaMask treats this method as disabled because the proposal is not readable.\n\n| Signing Methods        | Human readable | Efficient to process on-chain | Easy to use |\n| ---------------------- | -------------- | ----------------------------- | ----------- |\n| `eth_signTypedData_v4` | ✅             | ✅                            | ❌          |\n| `personal_sign`        | ✅             | ❌                            | ✅          |\n| `eth_sign`             | ❌             | ❓                            | ❌          |\n\nSee also: [A Brief History](#a-brief-history)","metadata":{"source":"signing-data"}}],["282",{"pageContent":"SignTypedData V4\n\nThis is currently the most readable signature method that is also efficient to process on-chain. It follows the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) standard to allow requesting the user sign a struct that can be verified on-chain. It produces confirmations that render the structure of a given struct, and tries to render that information as usefully as possible to the user (like displaying known account names in place of addresses).\n\n<img src=\"../assets/712.png\" alt=\"Sign typed data example\" style=\"width: 400px; position: relative; top: 20px;\" />\n\nA SignTypedData payload uses a standard format of encoding structs which is recursive, but has a different format for the top-level struct that is signed, which includes some `domain` metadata about the verifying contract to provide replay-protection of these signatures between different contract instances.\n\nThe top level SignTypedData object is the concatenation of:","metadata":{"source":"signing-data"}}],["283",{"pageContent":"The top level SignTypedData object is the concatenation of:\n\n- A `domain` struct, which can include the contract's address, chainId, a version, and a name, for cross-contract replay protection.\n- The top level struct hash to sign.\n\nThe format of an EIP-712 struct hash is the hash of the concatenation of:\n\n- A typestring, derived from the struct definition itself, defined in `encodeType` of the spec.\n- Each field of the struct, in the order defined by `encodeType` (alphabetical). Fields under 32 bytes are included in full, and fields over 32 bytes are hashed.\n\nInternally, MetaMask uses the [eth-sig-util](https://github.com/MetaMask/eth-sig-util) module to perform signatures and validation of EIP-712 code in JavaScript, so we recommend using it to generate and validate your own signatures.","metadata":{"source":"signing-data"}}],["284",{"pageContent":"You can use [eip712-codegen](https://github.com/danfinlay/eip712-codegen#readme) to generate most of the Solidity required to verify these signatures on-chain. It currently does not generate the top-level struct verification code (with the `domain`), though. That part will need to be written manually. You can see an example implementation [here](https://github.com/delegatable/delegatable-sol/blob/fb34bb259890417285f7185bc6500fb0ab8bf86f/contracts/Delegatable.sol#L80).\n\n::: warning Safety First!\nSince the top level struct type's name and the `domain.name` are presented to the user prominently in the confirmation, consider the names of your contract, the top level struct name, and the struct keys to be user-facing security interface. Will these labels catch the user's eye and keep them safe when a new website claiming to be an NFT giveaway presents it to them? It's up to you to make sure your contract is as readable as possible to the user.\n:::","metadata":{"source":"signing-data"}}],["285",{"pageContent":"Parameters","metadata":{"source":"signing-data"}}],["286",{"pageContent":"- `domain`: The domain is an options object with a number of optional fields that are used to ensure that signatures intended for your contract cannot be replayed on other contracts. You can opt out of these safety measures if you want your signatures to work across chains or contracts, for example.\n- `domain.name`: A human-readable name that will be shown to the user as the requesting contract. You should make it something familiar so the user would recognize it if a phishing site later requested a signature for your domain.\n- `domain.chainId`: The chain that these signatures should be valid on, if only one.\n- `domain.verifyingContract`: The address of the contract that will verify this contract, to ensure this signature is not also meaningful in unintended ways on other contracts. You can also provide a URL here.\n- `domain.version`: A number you can add as an extra level of replay protection. Probably totally overkill since you should be providing `verifyingContract` already.","metadata":{"source":"signing-data"}}],["287",{"pageContent":"- `domain.version`: A number you can add as an extra level of replay protection. Probably totally overkill since you should be providing `verifyingContract` already.\n- `primaryType`: The name of the type of the struct that you are requesting the user sign.\n- `types`: An object representing all of the solidity types that will be involved in signing the intended message.\n- `message`: An object representing the contents of the struct you are proposing the user sign.","metadata":{"source":"signing-data"}}],["288",{"pageContent":"Here are the parameter typescript definitions as defined in [eth-sig-util](https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts):\n\n```typescript\ninterface MessageTypeProperty {\n  name: string;\n  type: string;\n}\n\ninterface MessageTypes {\n  [additionalProperties: string]: MessageTypeProperty[];\n}\n\ninterface TypedMessage<T extends MessageTypes> {\n  types: T;\n  primaryType: keyof T;\n  domain: {\n    name?: string;\n    version?: string;\n    chainId?: number;\n    verifyingContract?: string;\n    salt?: ArrayBuffer;\n  };\n  message: Record<string, unknown>;\n}\n```","metadata":{"source":"signing-data"}}],["289",{"pageContent":"Example\n\nBelow is an example of signing typed data with MetaMask. Live example [here](https://metamask.github.io/test-dapp/#signTypedDataV4)\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab HTML\n\n```html\n<div>\n  <h3>Sign Typed Data V4</h3>\n  <button type=\"button\" id=\"signTypedDataV4Button\">sign typed data v4</button>\n</div>","metadata":{"source":"signing-data"}}],["290",{"pageContent":":::\n\n::: tab JavaScript\n\n```javascript\nsignTypedDataV4Button.addEventListener('click', async function (event) {\n  event.preventDefault();\n\n  const msgParams = JSON.stringify({\n    domain: {\n      // Defining the chain aka Rinkeby testnet or Ethereum Main Net\n      chainId: 1,\n      // Give a user friendly name to the specific contract you are signing for.\n      name: 'Ether Mail',\n      // If name isn't enough add verifying contract to make sure you are establishing contracts with the proper entity\n      verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n      // Just let's you know the latest version. Definitely make sure the field name is correct.\n      version: '1',\n    },","metadata":{"source":"signing-data"}}],["291",{"pageContent":"// Defining the message signing data content.\n    message: {\n      /*\n       - Anything you want. Just a JSON Blob that encodes the data you want to send\n       - No required fields\n       - This is DApp Specific\n       - Be as explicit as possible when building out the message schema.\n      */\n      contents: 'Hello, Bob!',\n      attachedMoneyInEth: 4.2,\n      from: {\n        name: 'Cow',\n        wallets: [\n          '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n          '0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF',\n        ],\n      },\n      to: [\n        {\n          name: 'Bob',\n          wallets: [\n            '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n            '0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57',\n            '0xB0B0b0b0b0b0B000000000000000000000000000',\n          ],\n        },\n      ],\n    },\n    // Refers to the keys of the *types* object below.\n    primaryType: 'Mail',\n    types: {\n      // TODO: Clarify if EIP712Domain refers to the domain the contract is hosted on\n      EIP712Domain: [","metadata":{"source":"signing-data"}}],["292",{"pageContent":"// Refers to the keys of the *types* object below.\n    primaryType: 'Mail',\n    types: {\n      // TODO: Clarify if EIP712Domain refers to the domain the contract is hosted on\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n      ],\n      // Not an EIP712Domain definition\n      Group: [\n        { name: 'name', type: 'string' },\n        { name: 'members', type: 'Person[]' },\n      ],\n      // Refer to PrimaryType\n      Mail: [\n        { name: 'from', type: 'Person' },\n        { name: 'to', type: 'Person[]' },\n        { name: 'contents', type: 'string' },\n      ],\n      // Not an EIP712Domain definition\n      Person: [\n        { name: 'name', type: 'string' },\n        { name: 'wallets', type: 'address[]' },\n      ],\n    },\n  });","metadata":{"source":"signing-data"}}],["293",{"pageContent":"var from = await web3.eth.getAccounts();\n\n  var params = [from[0], msgParams];\n  var method = 'eth_signTypedData_v4';\n\n  web3.currentProvider.sendAsync(\n    {\n      method,\n      params,\n      from: from[0],\n    },\n    function (err, result) {\n      if (err) return console.dir(err);\n      if (result.error) {\n        alert(result.error.message);\n      }\n      if (result.error) return console.error('ERROR', result);\n      console.log('TYPED SIGNED:' + JSON.stringify(result.result));\n\n      const recovered = sigUtil.recoverTypedSignature_v4({\n        data: JSON.parse(msgParams),\n        sig: result.result,\n      });\n\n      if (\n        ethUtil.toChecksumAddress(recovered) === ethUtil.toChecksumAddress(from)\n      ) {\n        alert('Successfully recovered signer as ' + from);\n      } else {\n        alert(\n          'Failed to verify signer when comparing ' + result + ' to ' + from\n        );\n      }\n    }\n  );\n});","metadata":{"source":"signing-data"}}],["294",{"pageContent":":::\n\n::::\n\n::: tip What Kind of Data Can it Sign?\nV4 of this method includes some improvements that are not available in older iterations of the method, so those methods are not recommended here.\n\n- V1 only allowed the signing of an array of primitive fields.\n- V2 was some minor improvements, and is not available on MetaMask.\n- V3 introduced signing structs.\n\nV4 added the ability to sign Arrays as well. So with V4, you're able to sign structs which contain any solidity primitive field, including arrays, and arrays of structs, although these structs are limited to the same constraints of other Solidity structs, including the inability to have circular types. If you have the need for circular types, you should probably make a linked list instead.\n:::","metadata":{"source":"signing-data"}}],["295",{"pageContent":"personal_sign\n\nThe personal sign method is a way to present the user with some human readable text for them to sign. It's often used for signature challenges that are authenticated on a web server, as with [Sign in with Ethereum (SiWE)](https://login.xyz/).\n\n<img src=\"../assets/personal_sign.png\" alt=\"Personal Sign Example\" style=\"width: 400px; position: relative; top: 20px;\" />\n\nSome other signers have implemented this same method as `eth_sign` because the geth client changed the behavior of their `eth_sign` method, but because of our need to continue supporting existing applications, we support the original behavior. You may need to check with the signers you support to see what method they use for a given implementation.\n\n::: warning Keeping users safe\nThis method is all about user readability, but the safety of your system relies on you using it responsibly!","metadata":{"source":"signing-data"}}],["296",{"pageContent":"::: warning Keeping users safe\nThis method is all about user readability, but the safety of your system relies on you using it responsibly!\n\n- Don't use this method to display binary data, or the user will not be able to understand what they're agreeing to.\n- If using this as a signature challenge, think about what would prevent a phisher from reusing the same challenge and impersonating your site: Add text referring to your domain, or the current time, so the user can easily verify if this challenge is legitimate.\n  :::\n\nFor historical reasons, the message to sign must be submitted to the method in hex-encoded UTF-8. Here is an exmample of generating that code using a node.js style `Buffer` shim in the browser, as used in our [example dapp](https://metamask.github.io/test-dapp/#personalSign).","metadata":{"source":"signing-data"}}],["297",{"pageContent":"Example\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab HTML\n\n```html\n<div>\n  <h3>Personal Sign</h3>\n  <button type=\"button\" id=\"personalSignButton\">personal_sign</button>\n</div>\n```\n\n:::\n\n::: tab JavaScript\n\n```javascript\npersonalSignButton.addEventListener('click', async function (event) {\n  event.preventDefault();\n  const exampleMessage = 'Example `personal_sign` message.';\n  try {\n    const from = accounts[0];\n    const msg = `0x${Buffer.from(exampleMessage, 'utf8').toString('hex')}`;\n    const sign = await ethereum.request({\n      method: 'personal_sign',\n      params: [msg, from, 'Example password'],\n    });\n    personalSignResult.innerHTML = sign;\n    personalSignVerify.disabled = false;\n  } catch (err) {\n    console.error(err);\n    personalSign.innerHTML = `Error: ${err.message}`;\n  }\n});","metadata":{"source":"signing-data"}}],["298",{"pageContent":":::\n\n::::\n\nThe requested text is prepended with `\\x19Ethereum Signed Message:\\n<length of message>` before being hashed and signed. You can try the method out in [our interactive API playground](https://metamask.github.io/api-playground/api-documentation/#personal_sign).","metadata":{"source":"signing-data"}}],["299",{"pageContent":"Signing Data with MetaMask\n\nIf you’d like to jump to some working signature examples, [you can visit this repository](https://github.com/MetaMask/test-dapp).\n\nIf you’d like to read our JavaScript implementations of these methods, they are all available in the npm package [eth-sig-util](https://github.com/MetaMask/eth-sig-util).\n\nNote that MetaMask supports signing transactions with Trezor and Ledger hardware wallets. These hardware wallets currently only support signing data using the `personal_sign` method. If you have trouble logging in to a website or dapp when using a Ledger or Trezor, the site may be requesting you sign data via an unsupported method, in which case we recommend using your standard MetaMask account.","metadata":{"source":"signing-data"}}],["300",{"pageContent":"A Brief History\n\nThere are currently six signing methods in MetaMask, and you might wonder the history of these methods. Studying the history of these methods yields some guiding lessons for the emergence of decentralized standards. Our current five methods are:\n\n- `eth_sign`\n- `personal_sign`\n- `signTypedData` (currently identical to `signTypedData_v1`)\n- `signTypedData_v1`\n- `signTypedData_v3`\n- `signTypedData_v4`\n\nThere are likely to be many more over time. When MetaMask first started, the Provider API wasn’t designed to be exposed to untrusted websites, and so some considerations weren’t taken as seriously as they were later.\n\nIn particular, the method `eth_sign` is an open-ended signing method that allows signing an arbitrary hash, which means it can be used to sign transactions, or any other data, making it a dangerous phishing risk.","metadata":{"source":"signing-data"}}],["301",{"pageContent":"For this reason, we have disabled the method by default and generally discourage using this method in production. However, there may be some applications (usually admin panels internal to teams) using this method for the sake of its ease of use or inability to change the associated dapp. If a wallet user needs to interact with a dapp that still uses it and accepts the risks, then they can still re-enable it through advanced settings.\n\nEventually, the `personal_sign` [spec](https://github.com/ethereum/go-ethereum/pull/2940) was proposed, which added a prefix to the data so it could not impersonate transactions. We also made this method able to display human readable text when UTF-8 encoded, making it a popular choice for site logins.\n\nHowever, the text-prefix made those signatures expensive to verify on-chain, and so with the help of the [0xProtocol](https://0x.org/) team and [SpankChain](https://spankchain.com/), the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) spec was written.","metadata":{"source":"signing-data"}}],["302",{"pageContent":"The strange part of EIP-712, and this decentralized standards ecosystem, is that the proposal changed several times while retaining the same EIP. This means what we initially implemented as `signTypedData` was the earliest proposed version, while other groups implemented later versions under the same method name.\n\nTo avoid compatibility issues between clients, we recommend using the hard-versioned method names `signTypedData_v1` and `signTypedData_v3`. The missing `v2` represents an intermediary design that was implemented by the Cipher browser, so that we have room to implement it if there is ever enough developer demand for it.","metadata":{"source":"signing-data"}}],["303",{"pageContent":"In the future, it may help to have method names include a hash of their exact proposal, since in a decentralized ecosystem, there is no absolute source of truth of what a given name should map to. Instead, we are forced to invent new patterns of collaboration, where we can drive forward and innovate, while simultaneously avoiding creating a brittle ecosystem by changing our meanings out from under the words.\n\nI hope this has been a useful introduction to the history of our signing methods!","metadata":{"source":"signing-data"}}],["304",{"pageContent":"Sign Typed Data v1\n\nThis early version of the spec lacked some later security improvements, and should generally be neglected in favor of [signTypedData_v3](#sign-typed-data-v3).\n\nAlso known as `signTypedData`, originally premiered October 2017 in [this blog post](https://medium.com/metamask/scaling-web3-with-signtypeddata-91d6efc8b290), this method was the original state-channel-centric signing method.\n\nThe `signTypedData` family has a few major design considerations:\n\n- Cheap to verify on chain\n- Still somewhat human readable\n- Hard to phish signatures\n\nIf on-chain verifiability cost is a high priority for you, you might want to consider it.","metadata":{"source":"signing-data"}}],["305",{"pageContent":"Sign Typed Data v3\n\nThe method `signTypedData_v3` is a highly used version of the [EIP-712 spec](https://eips.ethereum.org/EIPS/eip-712).\n\nThis does not mean it is perfect. Most recently, we released `v4`, but we intend to protect this namespace and keep it compatible going forwards.\n\nWe have a [great introductory blog post to this method here](https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26).\n\nHopefully soon we will also have good examples for parsing method input into structs for verification on-chain (great contribution opportunity!)","metadata":{"source":"signing-data"}}],["306",{"pageContent":"# RPC API\n\nMetaMask uses the [`ethereum.request(args)` method](./ethereum-provider.html#ethereum-request-args) to wrap an RPC API.\n\nThe API is based on an interface exposed by all Ethereum clients, along with a growing number of methods that may or may not be supported by other wallets.\n\n::: tip Tip\nAll RPC method requests can return errors.\nMake sure to handle errors for every call to `ethereum.request(args)`.\n:::\n\n::: tip Try Ethereum Methods\nVisit our [API Playground](https://metamask.github.io/api-playground/api-documentation/)\n:::\n\n## Table of Contents\n\n[[toc]]","metadata":{"source":"rpc-api"}}],["307",{"pageContent":"Table of Contents\n\n[[toc]]\n\n## Ethereum JSON-RPC Methods\n\nFor the Ethereum JSON-RPC API, please see [the Ethereum wiki](https://eth.wiki/json-rpc/API#json-rpc-methods).\n\nImportant methods from this API include:\n\n- [`eth_accounts`](https://eth.wiki/json-rpc/API#eth_accounts)\n- [`eth_call`](https://eth.wiki/json-rpc/API#eth_call)\n- [`eth_getBalance`](https://eth.wiki/json-rpc/API#eth_getbalance)\n- [`eth_sendTransaction`](https://eth.wiki/json-rpc/API#eth_sendtransaction)\n- [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)","metadata":{"source":"rpc-api"}}],["308",{"pageContent":"Restricted Methods\n\nMetaMask introduced Web3 Wallet Permissions via [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).\nIn this permissions system, each RPC method is either _restricted_ or _unrestricted_.\nIf a method is restricted, the caller must have the corresponding permission in order to call it.\nUnrestricted methods, meanwhile, have no corresponding permission. Some of them still rely upon permissions to succeed though (e.g. the signing methods require that you have the `eth_accounts` permission for the signer account), and some require confirmation by the user (e.g. `wallet_addEthereumChain`).\n\nWith the exception of [MetaMask Flask](https://metamask.io/flask), the only existing permission is `eth_accounts`, which allows you to access the user's Ethereum address(es).\nMore permissions will be added in the future.","metadata":{"source":"rpc-api"}}],["309",{"pageContent":"Under the hood, permissions are plain, JSON-compatible objects, with a number of fields that are mostly used internally by MetaMask.\nThe following interface lists the fields that may be of interest to consumers:\n\n```typescript\ninterface Web3WalletPermission {\n  // The name of the method corresponding to the permission\n  parentCapability: string;\n\n  // The date the permission was granted, in UNIX epoch time\n  date?: number;\n}","metadata":{"source":"rpc-api"}}],["310",{"pageContent":"If you're interested in learning more about the theory behind this _capability_-inspired permissions system, we encourage you to take a look at [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).","metadata":{"source":"rpc-api"}}],["311",{"pageContent":"`eth_requestAccounts`\n\n::: tip EIP-1102\nThis method is specified by [EIP-1102](https://eips.ethereum.org/EIPS/eip-1102).\nIt is equivalent to the deprecated [`ethereum.enable()`](./ethereum-provider.html#ethereum-enable) provider API method.\n\nUnder the hood, it calls [`wallet_requestPermissions`](#wallet-requestpermissions) for the `eth_accounts` permission.\nSince `eth_accounts` is currently the only permission, this method is all you need for now.\n:::\n\n#### Returns\n\n`string[]` - An array of a single, hexadecimal Ethereum address string.","metadata":{"source":"rpc-api"}}],["312",{"pageContent":"Returns\n\n`string[]` - An array of a single, hexadecimal Ethereum address string.\n\n#### Description\n\nRequests that the user provides an Ethereum address to be identified by.\nReturns a Promise that resolves to an array of a single Ethereum address string.\nIf the user denies the request, the Promise will reject with a `4001` error.\n\nThe request causes a MetaMask popup to appear.\nYou should only request the user's accounts in response to user action, such as a button click.\nYou should always disable the button that caused the request to be dispatched, while the request is still pending.\n\nIf you can't retrieve the user's account(s), you should encourage the user to initiate an account request.","metadata":{"source":"rpc-api"}}],["313",{"pageContent":"Example\n\n```javascript\ndocument.getElementById('connectButton', connect);\n\nfunction connect() {\n  ethereum\n    .request({ method: 'eth_requestAccounts' })\n    .then(handleAccountsChanged)\n    .catch((error) => {\n      if (error.code === 4001) {\n        // EIP-1193 userRejectedRequest error\n        console.log('Please connect to MetaMask.');\n      } else {\n        console.error(error);\n      }\n    });\n}\n```","metadata":{"source":"rpc-api"}}],["314",{"pageContent":"`wallet_getPermissions`\n\n::: tip Platform Availability\nThis RPC method is not yet available in MetaMask Mobile.\n:::\n\n#### Returns\n\n`Web3WalletPermission[]` - An array of the caller's permissions.\n\n#### Description\n\nGets the caller's current permissions.\nReturns a Promise that resolves to an array of `Web3WalletPermission` objects.\nIf the caller has no permissions, the array will be empty.","metadata":{"source":"rpc-api"}}],["315",{"pageContent":"`wallet_requestPermissions`\n\n::: tip Platform Availability\nThis RPC method is not yet available in MetaMask Mobile.\n:::\n\n#### Parameters\n\n- `Array`\n\n  0. `RequestedPermissions` - The requested permissions.\n\n```typescript\ninterface RequestedPermissions {\n  [methodName: string]: {}; // an empty object, for future extensibility\n}\n```\n\n#### Returns\n\n`Web3WalletPermission[]` - An array of the caller's permissions.\n\n#### Description\n\nRequests the given permissions from the user.\nReturns a Promise that resolves to a non-empty array of `Web3WalletPermission` objects, corresponding to the caller's current permissions.\nIf the user denies the request, the Promise will reject with a `4001` error.\n\nThe request causes a MetaMask popup to appear.\nYou should only request permissions in response to user action, such as a button click.","metadata":{"source":"rpc-api"}}],["316",{"pageContent":"Example\n\n```javascript\ndocument.getElementById('requestPermissionsButton', requestPermissions);\n\nfunction requestPermissions() {\n  ethereum\n    .request({\n      method: 'wallet_requestPermissions',\n      params: [{ eth_accounts: {} }],\n    })\n    .then((permissions) => {\n      const accountsPermission = permissions.find(\n        (permission) => permission.parentCapability === 'eth_accounts'\n      );\n      if (accountsPermission) {\n        console.log('eth_accounts permission successfully requested!');\n      }\n    })\n    .catch((error) => {\n      if (error.code === 4001) {\n        // EIP-1193 userRejectedRequest error\n        console.log('Permissions needed to continue.');\n      } else {\n        console.error(error);\n      }\n    });\n}\n```","metadata":{"source":"rpc-api"}}],["317",{"pageContent":"Unrestricted Methods","metadata":{"source":"rpc-api"}}],["318",{"pageContent":"`eth_decrypt` (DEPRECATED)\n\n::: warning\nThis method is deprecated and may be removed in the future.\n\n[See here for more information.](https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686)\n:::\n\n::: tip Platform Availability\nThis RPC method is not available in MetaMask Mobile.\n:::\n\n#### Parameters\n\n- `Array`\n\n  0. `string` - An encrypted message.\n  1. `string` - The address of the Ethereum account that can decrypt the message.\n\n#### Returns\n\n`string` - The decrypted message.\n\n#### Description\n\nRequests that MetaMask decrypts the given encrypted message.\nThe message must have been encrypted using the public encryption key of the given Ethereum address.\nReturns a Promise that resolves to the decrypted message, or rejects if the decryption attempt fails.\n\nSee [`eth_getEncryptionPublicKey`](#eth-getencryptionpublickey) for more information.","metadata":{"source":"rpc-api"}}],["319",{"pageContent":"Example\n\n```javascript\nethereum\n  .request({\n    method: 'eth_decrypt',\n    params: [encryptedMessage, accounts[0]],\n  })\n  .then((decryptedMessage) =>\n    console.log('The decrypted message is:', decryptedMessage)\n  )\n  .catch((error) => console.log(error.message));\n```","metadata":{"source":"rpc-api"}}],["320",{"pageContent":"`eth_getEncryptionPublicKey` (DEPRECATED)\n\n::: warning\nThis method is deprecated and may be removed in the future.\n\n[See here for more information.](https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686)\n:::\n\n::: tip Platform Availability\nThis RPC method is not available in MetaMask Mobile.\n:::\n\n#### Parameters\n\n- `Array`\n\n  0. `string` - The address of the Ethereum account whose encryption key should be retrieved.\n\n#### Returns\n\n`string` - The public encryption key of the specified Ethereum account.\n\n#### Description\n\nRequests that the user shares their public encryption key.\nReturns a Promise that resolve to the public encryption key, or rejects if the user denied the request.\n\nThe public key is computed from entropy associated with the specified user account, using the [`nacl`](https://github.com/dchest/tweetnacl-js) implementation of the `X25519_XSalsa20_Poly1305` algorithm.","metadata":{"source":"rpc-api"}}],["321",{"pageContent":"Example\n\n```javascript\nlet encryptionPublicKey;\n\nethereum\n  .request({\n    method: 'eth_getEncryptionPublicKey',\n    params: [accounts[0]], // you must have access to the specified account\n  })\n  .then((result) => {\n    encryptionPublicKey = result;\n  })\n  .catch((error) => {\n    if (error.code === 4001) {\n      // EIP-1193 userRejectedRequest error\n      console.log(\"We can't encrypt anything without the key.\");\n    } else {\n      console.error(error);\n    }\n  });\n```","metadata":{"source":"rpc-api"}}],["322",{"pageContent":"Encrypting\n\nThe point of the encryption key is of course to encrypt things.\nHere's an example of how to encrypt a message using [`eth-sig-util`](https://github.com/MetaMask/eth-sig-util):\n\n```javascript\nconst ethUtil = require('ethereumjs-util');\nconst sigUtil = require('@metamask/eth-sig-util');\n\nconst encryptedMessage = ethUtil.bufferToHex(\n  Buffer.from(\n    JSON.stringify(\n      sigUtil.encrypt({\n        publicKey: encryptionPublicKey,\n        data: 'hello world!',\n        version: 'x25519-xsalsa20-poly1305',\n      })\n    ),\n    'utf8'\n  )\n);\n```","metadata":{"source":"rpc-api"}}],["323",{"pageContent":"`wallet_addEthereumChain`\n\n::: tip EIP-3085\nThis method is specified by [EIP-3085](https://eips.ethereum.org/EIPS/eip-3085).\n:::\n\n#### Parameters\n\n- `Array`\n\n  0. `AddEthereumChainParameter` - Metadata about the chain that will be added to MetaMask.\n\nFor the `rpcUrls` and `blockExplorerUrls` arrays, at least one element is required, and only the first element will be used.\n\n```typescript\ninterface AddEthereumChainParameter {\n  chainId: string; // A 0x-prefixed hexadecimal string\n  chainName: string;\n  nativeCurrency: {\n    name: string;\n    symbol: string; // 2-6 characters long\n    decimals: 18;\n  };\n  rpcUrls: string[];\n  blockExplorerUrls?: string[];\n  iconUrls?: string[]; // Currently ignored.\n}\n```\n\n#### Returns\n\n`null` - The method returns `null` if the request was successful, and an error otherwise.","metadata":{"source":"rpc-api"}}],["324",{"pageContent":"Description\n\nCreates a confirmation asking the user to add the specified chain to MetaMask.\nThe user may choose to switch to the chain once it has been added.\n\nAs with any method that causes a confirmation to appear, `wallet_addEthereumChain`\nshould **only** be called as a result of direct user action, such as the click of a button.\n\nMetaMask stringently validates the parameters for this method, and will reject the request\nif any parameter is incorrectly formatted.\nIn addition, MetaMask will automatically reject the request under the following circumstances:\n\n- If the RPC endpoint doesn't respond to RPC calls.\n  NOTE: Calls are made from the extension's background page, _not_ the foreground page. If you use an origin allowlist, they will be blocked.\n- If the RPC endpoint returns a different chain ID when `eth_chainId` is called.\n- If the chain ID corresponds to any default MetaMask chains.","metadata":{"source":"rpc-api"}}],["325",{"pageContent":"MetaMask does not yet support chains with native currencies that do not have 18 decimals,\nbut may do so in the future.","metadata":{"source":"rpc-api"}}],["326",{"pageContent":"Usage with `wallet_switchEthereumChain`\n\nWe recommend using this method with [`wallet_addEthereumChain`](#wallet-addethereumchain):\n\n```javascript\ntry {\n  await ethereum.request({\n    method: 'wallet_switchEthereumChain',\n    params: [{ chainId: '0xf00' }],\n  });\n} catch (switchError) {\n  // This error code indicates that the chain has not been added to MetaMask.\n  if (switchError.code === 4902) {\n    try {\n      await ethereum.request({\n        method: 'wallet_addEthereumChain',\n        params: [\n          {\n            chainId: '0xf00',\n            chainName: '...',\n            rpcUrls: ['https://...'] /* ... */,\n          },\n        ],\n      });\n    } catch (addError) {\n      // handle \"add\" error\n    }\n  }\n  // handle other \"switch\" errors\n}\n```","metadata":{"source":"rpc-api"}}],["327",{"pageContent":"`wallet_switchEthereumChain`\n\n::: tip EIP-3326\nThis method is specified by [EIP-3326](https://ethereum-magicians.org/t/eip-3326-wallet-switchethereumchain).\n:::\n\n#### Parameters\n\n- `Array`\n\n  0. `SwitchEthereumChainParameter` - Metadata about the chain that MetaMask will switch to.\n\n```typescript\ninterface SwitchEthereumChainParameter {\n  chainId: string; // A 0x-prefixed hexadecimal string\n}\n```\n\n#### Returns\n\n`null` - The method returns `null` if the request was successful, and an error otherwise.\n\nIf the error code (`error.code`) is `4902`, then the requested chain has not been added by MetaMask, and you have to request to add it via [`wallet_addEthereumChain`](#wallet-addethereumchain).","metadata":{"source":"rpc-api"}}],["328",{"pageContent":"Description\n\n::: tip Tip\nSee [above](#usage-with-wallet-switchethereumchain) for how to use this method with `wallet_addEthereumChain`.\n:::\n\nCreates a confirmation asking the user to switch to the chain with the specified `chainId`.\n\nAs with any method that causes a confirmation to appear, `wallet_switchEthereumChain`\nshould **only** be called as a result of direct user action, such as the click of a button.\n\nMetaMask will automatically reject the request under the following circumstances:\n\n- If the chain ID is malformed\n- If the chain with the specified chain ID has not been added to MetaMask","metadata":{"source":"rpc-api"}}],["329",{"pageContent":"`wallet_registerOnboarding`\n\n::: tip Tip\nAs an API consumer, you are unlikely to have to call this method yourself.\nPlease see the [Onboarding Library documentation](./onboarding-library.html) for more information.\n:::\n\n#### Returns\n\n`boolean` - `true` if the request was successful, `false` otherwise.\n\n#### Description\n\nRegisters the requesting site with MetaMask as the initiator of onboarding.\nReturns a Promise that resolves to `true`, or rejects if there's an error.\n\nThis method is intended to be called after MetaMask has been installed, but before the MetaMask onboarding has completed.\nYou can use this method to inform MetaMask that you were the one that suggested installing MetaMask.\nThis lets MetaMask redirect the user back to your site after onboarding has completed.\n\nInstead of calling this method directly, you should use the [`@metamask/onboarding` library](https://github.com/MetaMask/metamask-onboarding).","metadata":{"source":"rpc-api"}}],["330",{"pageContent":"`wallet_watchAsset`\n\n::: tip EIP-747\nThis method is specified by [EIP-747](https://eips.ethereum.org/EIPS/eip-747).\n:::\n\n#### Parameters\n\n- `WatchAssetParams` - The metadata of the asset to watch.\n\n<<< @/docs/snippets/WatchAssetParams.ts\n\n#### Returns\n\n`boolean` - `true` if the the token was added, `false` otherwise.\n\n#### Description\n\nRequests that the user tracks the token in MetaMask.\nReturns a `boolean` indicating if the token was successfully added.\n\nMost Ethereum wallets support some set of tokens, usually from a centrally curated registry of tokens.\n`wallet_watchAsset` enables web3 application developers to ask their users to track tokens in their wallets, at runtime.\nOnce added, the token is indistinguishable from those added via legacy methods, such as a centralized registry.","metadata":{"source":"rpc-api"}}],["331",{"pageContent":"Example\n\n```javascript\nethereum\n  .request({\n    method: 'wallet_watchAsset',\n    params: {\n      type: 'ERC20',\n      options: {\n        address: '0xb60e8dd61c5d32be8058bb8eb970870f07233155',\n        symbol: 'FOO',\n        decimals: 18,\n        image: 'https://foo.io/token-image.svg',\n      },\n    },\n  })\n  .then((success) => {\n    if (success) {\n      console.log('FOO successfully added to wallet!');\n    } else {\n      throw new Error('Something went wrong.');\n    }\n  })\n  .catch(console.error);\n```","metadata":{"source":"rpc-api"}}],["332",{"pageContent":"Mobile Specific RPC Methods","metadata":{"source":"rpc-api"}}],["333",{"pageContent":"`wallet_scanQRCode`\n\n#### Parameters\n\n- `Array`\n\n  0. `string` - (optional) A regular expression for matching arbitrary QR code strings\n\n#### Returns\n\n`string` - The string corresponding to the scanned QR code.\n\n#### Description\n\nRequests that the user scans a QR code using their device camera.\nReturns a Promise that resolves to a string, matching either:\n\n1. The regex parameter, if provided\n2. An ethereum address, if no regex parameter was provided\n\nIf neither condition is met, the Promise will reject with an error.\n\nMetaMask previously introduced this feature per the proposed [EIP-945](https://github.com/ethereum/EIPs/issues/945).\nThe functionality was temporarily removed before being reintroduced as this RPC method.","metadata":{"source":"rpc-api"}}],["334",{"pageContent":"Example\n\n```javascript\nethereum\n  .request({\n    method: 'wallet_scanQRCode',\n    // The regex string must be valid input to the RegExp constructor, if provided\n    params: ['\\\\D'],\n  })\n  .then((result) => {\n    console.log(result);\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n```","metadata":{"source":"rpc-api"}}],["335",{"pageContent":"# Snaps JSON-RPC API\n\n::: tip Developer Preview Software\nSnaps is pre-release software. To try Snaps, install [MetaMask Flask](https://metamask.io/flask).\n:::\n\n::: tip Feature Requests\nDo you have feature requests? Other ideas? We'd love to hear about them! [Click here](https://github.com/MetaMask/snaps-monorepo/discussions) to join the discussion.\n:::\n\n## Table of Contents\n\n[[toc]]","metadata":{"source":"snaps-rpc-api"}}],["336",{"pageContent":"Unrestricted Methods","metadata":{"source":"snaps-rpc-api"}}],["337",{"pageContent":"`wallet_requestSnaps`\n\n::: warning Only Callable By\n\n- Websites\n  :::\n\n#### Parameters\n\n- `Object`\n\n```typescript\ninterface RequestSnapsParams {\n  [snapId: string]: {\n    version?: string;\n  };\n}\n```\n\n#### Returns\n\n```typescript\ninterface RequestSnapsResult {\n  [snapId: string]: WalletGetSnapsResult[string];\n}\n```\n\n`RequestSnapsResult` - An object mapping the IDs of installed snaps to their metadata or an error if installation failed.","metadata":{"source":"snaps-rpc-api"}}],["338",{"pageContent":"Description\n\nThis method requests permission for a DApp to communicate with the given snaps and attempts to install them if they aren't already.\nIf the installation of any snap fails, `wallet_requestSnaps` will throw with the error that caused the installation to fail.\n\nOptionally, you can specify a [SemVer range](https://www.npmjs.com/package/semver) for any snap to be installed.\nIf you do so, MetaMask will try to install a version of the snap that satisfies the requested range.\nIf a compatible version of a snap is already installed, the request to install that snap will automatically succeed.\nIf an incompatible version is installed, MetaMask will attempt to update the snap to the latest version that satisfies the requested range.\nThe request will succeed if the snap is successfully updated, and fail if the update could not be completed.","metadata":{"source":"snaps-rpc-api"}}],["339",{"pageContent":"Example\n\n```javascript\ntry {\n  const result = await ethereum.request({\n    method: 'wallet_requestSnaps',\n    params: {\n      'npm:@metamask/example-snap': {},\n      'npm:fooSnap': {\n        // The optional version argument allows requesting a SemVer version\n        // range, with the same semantics as npm package.json ranges.\n        version: '^1.0.2',\n      },\n    },\n  });\n\n  console.log(result);\n  // Will print something of the form:\n  // {\n  //   'npm:@metamask/example-snap': {\n  //     version: '1.0.0',\n  //     permissionName: 'wallet_snap_npm:@metamask/example-snap',\n  //     ...\n  //   },\n  //   'npm:fooSnap': {\n  //     version: '1.0.5',\n  //     permissionName: 'wallet_snap_npm:fooSnap',\n  //     ...\n  //   },\n  // }\n} catch (error) {\n  console.log(error);\n  // Will print something of the form:\n  // {\n  //    message: 'The snap does not exist.'\n  // }\n}\n```","metadata":{"source":"snaps-rpc-api"}}],["340",{"pageContent":"`wallet_getSnaps`\n\n::: warning Only Callable By\n\n- Websites\n  :::\n\n#### Returns\n\n```typescript\ninterface WalletGetSnapsResult {\n  [snapId: string]: {\n    /**\n     * The ID of the Snap.\n     */\n    id: SnapId;\n\n    /**\n     * The initial permissions of the Snap, which will be requested when it is\n     * installed.\n     */\n    initialPermissions: RequestedSnapPermissions;\n\n    /**\n     * The name of the permission used to invoke the Snap.\n     */\n    permissionName: string;\n\n    /**\n     * The version of the Snap.\n     */\n    version: string;\n  };\n}\n```\n\n`WalletGetSnapsResult` - An object containing the requester's permitted snaps.\n\n#### Description\n\nThis method returns the IDs of the caller's permitted snaps and some relevant metadata.","metadata":{"source":"snaps-rpc-api"}}],["341",{"pageContent":"Description\n\nThis method returns the IDs of the caller's permitted snaps and some relevant metadata.\n\n#### Example\n\n```javascript\nconst result = await ethereum.request({ method: 'wallet_getSnaps' });\n\nconsole.log(result);\n// If any snaps are permitted, will print e.g.:\n// {\n//   accountRPC methods?s: ['0xa...', '0xb...'],\n//   permissions: {\n//     eth_accounts: {},\n//     'wallet_snap_npm:@metamask/example-snap': {},\n//   },\n//   snaps: {\n//     'npm:@metamask/example-snap': {\n//       version: '1.0.0',\n//       permissionName: 'wallet_snap_npm:@metamask/example-snap',\n//       ...\n//     }\n//   }\n// }\n```","metadata":{"source":"snaps-rpc-api"}}],["342",{"pageContent":"`wallet_invokeSnap`\n\n::: warning Only Callable By\n\n- Websites\n  :::\n\n#### Parameters\n\n```typescript\n/**\n * This is a less stringent version of the JSON-RPC 2.0 request object\n * interface. Keep in mind that snaps specify and implement their own JSON-RPC\n * APIs, and may require the `id` and `jsonrpc` fields if they wish.\n */\ninterface SnapRequest {\n  method: string;\n  params?: unknown[] | Record<string, unknown>;\n  id?: string | number;\n  jsonrpc?: '2.0';\n}\n```\n\n- `Object`\n  - `snapId` - `string` - The id of the snap to invoke.\n  - `request` - `SnapRequest` - The JSON-RPC request object to send to the invoked snap.\n\n#### Returns\n\n`unknown` - The result of the snap method call.","metadata":{"source":"snaps-rpc-api"}}],["343",{"pageContent":"Returns\n\n`unknown` - The result of the snap method call.\n\n#### Description\n\nInvokes the specified JSON-RPC method of the specified snap.\nThe snap must be installed and the caller must have the permission to communicate with the snap, or the request will be rejected.\n\nSnaps are fully responsible for implementing their JSON-RPC API; consult the snap's documentation for available methods, their parameters, and return values.\n\n#### Example\n\n```javascript\nconst result = await ethereum.request({\n  method: 'wallet_invokeSnap',\n  params: {\n    snapId: 'npm:@metamask/example-snap',\n    request: {\n      method: 'hello',\n    },\n  },\n});\n\nconsole.log(result); // We happen to know that this will be `true` or `false`\n```","metadata":{"source":"snaps-rpc-api"}}],["344",{"pageContent":"Restricted Methods\n\nIf a method is _restricted_, it means that you need the requisite permission before you can call it.\nBoth snaps and Dapps / websites can have permissions.\nSome permissions are only available to snaps, and some are only available to websites.\nSee [here](./rpc-api.html#restricted-methods) for more information about the permission system.","metadata":{"source":"snaps-rpc-api"}}],["345",{"pageContent":"`wallet_snap_*`\n\n::: warning Only Callable By\n\n- Websites\n  :::\n\n::: warning Is this the method you're looking for?\n[`wallet_invokeSnap`](#wallet-invokesnap) provides a more convenient way of calling this method.\n:::\n\n::: tip Namespaced Method\nThis is a namespaced restricted method.\nThe `*` in the name will always be substituted for a string, in this case a snap ID.\n:::\n\n#### Parameters\n\n- `Object` (`SnapRequest`)\n  - The JSON-RPC request object to send to the invoked snap.\n\n#### Returns\n\n`unknown` - The result of the snap method call.\n\n#### Description\n\nInvokes the specified JSON-RPC method of the snap corresponding to the specified permission name.\nThe snap must be installed and the caller must have the permission to communicate with the snap, or the request will be rejected.\n\nSnaps are fully responsible for implementing their JSON-RPC API; consult the snap's documentation for available methods, their parameters, and return values.","metadata":{"source":"snaps-rpc-api"}}],["346",{"pageContent":"Example\n\n```javascript\nconst result = await ethereum.request({\n  method: 'wallet_snap_npm:@metamask/example-snap',\n  params: {\n    method: 'hello',\n  },\n});\n\nconsole.log(result); // We happen to know that this will be `true` or `false`\n```","metadata":{"source":"snaps-rpc-api"}}],["347",{"pageContent":"`snap_confirm`\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Parameters\n\n```typescript\ninterface SnapConfirmParam {\n  /**\n   * A prompt, phrased as a question, no greater than 40 characters long.\n   */\n  prompt: string;\n\n  /**\n   * A description, displayed with the prompt, no greater than 140 characters\n   * long.\n   */\n  description?: string;\n\n  /**\n   * Free-from text content, no greater than 1800 characters long.\n   * It will be displayed in monospace font in a scrollable text area.\n   */\n  textAreaContent?: string;\n}\n```\n\n- `Array`\n\n  0. `SnapConfirmParam` - An object containing the contents of the confirmation.\n\n#### Returns\n\n`boolean` - `true` if the user accepted the confirmation, and `false` otherwise.","metadata":{"source":"snaps-rpc-api"}}],["348",{"pageContent":"Returns\n\n`boolean` - `true` if the user accepted the confirmation, and `false` otherwise.\n\n#### Description\n\nCalling this method causes a confirmation to be displayed in the MetaMask UI.\nThe contents of the confirmation depend on the parameters, see above for their meaning and format.\nThe user can either approve or reject the confirmation, which will be indicated by the method's return value.\n\n#### Example\n\n```javascript\nconst result = await snap.request({\n  method: 'snap_confirm',\n  params: [\n    {\n      prompt: 'Would you like to take the action?',\n      description: 'The action is...',\n      textAreaContent: 'Very detailed information about the action...',\n    },\n  ],\n});\n\nif (result === true) {\n  // Take the action\n} else {\n  // Do not take the action\n}\n```","metadata":{"source":"snaps-rpc-api"}}],["349",{"pageContent":"`snap_dialog`\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Description\n\nCalling this method causes a dialog to be displayed in the MetaMask UI.\nThere are three types of dialogs: Alert, Confirmation, and Prompt.\nEach of these dialog types has different parameters and return types, detailed below.\n\n#### The `Component` type\n\nThe `Component` type, used as the `content` property for dialogs, is [defined in source code](https://github.com/MetaMask/snaps-monorepo/blob/main/packages/snaps-ui/src/nodes.ts#L171) as:\n\n```typescript\ntype Component = Infer<typeof ComponentStruct>;\n```\n\nBy itself this is opaque. A simple way to understand it is as the return type of the UI functions exported from the `@metamask/snaps-ui` package, i.e. `heading`, `panel`, `text`, and other UI functions.","metadata":{"source":"snaps-rpc-api"}}],["350",{"pageContent":"Alert Dialog\n\nDisplays an alert that can only be acknowledged.\n\n##### Parameters\n\n```typescript\ninterface SnapAlertDialogParam {\n  /**\n   * The type of the dialog.\n   */\n  type: 'Alert';\n\n  /**\n   * The content of the alert, as a Custom UI component\n   */\n  content: Component;\n}\n```\n\n##### Returns\n\n`null`\n\n##### Example\n\n```typescript\nimport { panel, text, heading } from '@metamask/snaps-ui';\n\nawait snap.request({\n  method: 'snap_dialog',\n  params: {\n    type: 'Alert',\n    content: panel([\n      heading('Something happened in the system'),\n      text('The thing that happened is...'),\n    ]),\n  },\n});\n\n// Code that should execute after the alert has been acknowledged\n```","metadata":{"source":"snaps-rpc-api"}}],["351",{"pageContent":"Confirmation Dialog\n\nDisplays a confirmation dialog that can be accepted or rejected.\n\n##### Parameters\n\n```typescript\ninterface SnapConfirmationDialogParam {\n  /**\n   * The type of the dialog.\n   */\n  type: 'Confirmation';\n\n  /**\n   * The content of the confirmation, as a Custom UI component\n   */\n  content: Component;\n}\n```\n\n##### Returns\n\n`boolean` - `true` if the confirmation was accepted, `false` otherwise.\n\n##### Example\n\n```typescript\nimport { panel, text, heading } from '@metamask/snaps-ui';\n\nconst result = await snap.request({\n  method: 'snap_dialog',\n  params: {\n    type: 'Confirmation',\n    content: panel([\n      heading('Would you like to take the action?'),\n      text('The action is...'),\n    ]),\n  },\n});\n\nif (result === true) {\n  // Do the action\n}\n```","metadata":{"source":"snaps-rpc-api"}}],["352",{"pageContent":"Prompt Dialog\n\nDisplays a prompt where the user can enter a text response.\n\n##### Parameters\n\n```typescript\ninterface SnapPromptDialogParam {\n  /**\n   * The type of the dialog.\n   */\n  type: 'Prompt';\n\n  /**\n   * The content of the prompt, as a Custom UI component.\n   */\n  content: Component;\n\n  /**\n   * Text that will be in the input field when nothing is typed.\n   */\n  placeholder: string;\n}\n```\n\n##### Returns\n\n`string` - The text entered by the user.\n\n##### Example\n\n```typescript\nimport { panel, text, heading } from '@metamask/snaps-ui';\n\nconst walletAddress = await snap.request({\n  method: 'snap_dialog',\n  params: {\n    type: 'Prompt',\n    content: panel([\n      heading('What is the wallet address?'),\n      text('Please enter the wallet address to be monitored'),\n    ]),\n    placeholder: '0x123...',\n  },\n});\n\n// `walletAddress` will be a string containing the address entered by the user\n```","metadata":{"source":"snaps-rpc-api"}}],["353",{"pageContent":"`snap_getBip32Entropy`\n\n::: danger Powerful Method\nIf you call this method, you will receive the user's parent key for the derivation path that they requested.\nWhen that happens, you are now managing a person's keys, and whatever assets they control, on their behalf.\nTheir safety is your responsibility.\n:::\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Parameters\n\n- `Object`\n  - `path` - An array, starting with `m`, containing the BIP-32 derivation path to the key to retrieve, e.g., `[\"m\", \"44'\", \"60'\"]`.\n  - `curve` - The curve to use for the key derivation, must be `'ed25519'` or `'secp256k1'`.","metadata":{"source":"snaps-rpc-api"}}],["354",{"pageContent":"Returns\n\n```typescript\ninterface SLIP10Node {\n  /**\n   * The 0-indexed path depth of this node.\n   */\n  readonly depth: number;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The private key of this node.\n   */\n  readonly privateKey: string;\n\n  /**\n   * The public key of this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The chain code of this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * The name of the curve used by the node.\n   */\n  readonly curve: 'ed25519' | 'secp256k1';\n}\n```\n\n`SLIP10Node` - An object representing the [SLIP-10](https://github.com/satoshilabs/slips/blob/master/slip-0010.md) HD Tree node and containing its corresponding key material.","metadata":{"source":"snaps-rpc-api"}}],["355",{"pageContent":"Description\n\nGets the [SLIP-10](https://github.com/satoshilabs/slips/blob/master/slip-0010.md) key for the `path` and `curve` specified by the method name.\nThis is the \"key management\" permission of Snaps; use it with the utmost care.\n\nThis restricted method is both implemented and designed to be used with [`@metamask/key-tree`](https://npmjs.com/package/@metamask/key-tree).\nSee the `@metamask/key-tree` documentation and below example for more information.\n\nNote that `@metamask/key-tree` can help you get the [extended private keys](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys) for user addresses, but it is your responsibility to know how to use those keys to e.g. derive an address for the relevant protocol or sign a transaction for the user.","metadata":{"source":"snaps-rpc-api"}}],["356",{"pageContent":"Example\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab Manifest\n\n```json\n{\n  \"initialPermissions\": {\n    \"snap_getBip32Entropy\": [\n      {\n        \"path\": [\"m\", \"44'\", \"3'\"],\n        \"curve\": \"secp256k1\" // Or \"ed25519\"\n      }\n    ]\n  }\n}","metadata":{"source":"snaps-rpc-api"}}],["357",{"pageContent":":::\n\n::: tab Code\n\n```javascript\nimport { SLIP10Node } from '@metamask/key-tree';\n\n// By way of example, we will use Dogecoin, which has a derivation path starting\n// with `m/44'/3'`.\nconst dogecoinNode = await snap.request({\n  method: 'snap_getBip32Entropy',\n  params: {\n    // Must be specified exactly in the manifest\n    path: ['m', \"44'\", \"3'\"],\n    curve: 'secp256k1',\n  },\n});\n\n// Next, we'll create an instance of a SLIP-10 node for the Dogecoin node.\nconst dogecoinSlip10Node = await SLIP10Node.fromJSON(dogecoinNode);\n\n// m / 44' / 3' / 0'\nconst accountKey0 = await dogecoinSlip10Node.derive([\"bip32:0'\"]);\n\n// m / 44' / 3' / 1'\nconst accountKey1 = await dogecoinSlip10Node.derive([\"bip32:1'\"]);\n\n// Now, you can ask the user to e.g. sign transactions!\n```\n\n:::\n\n::::","metadata":{"source":"snaps-rpc-api"}}],["358",{"pageContent":"`snap_getBip44Entropy`\n\n::: danger Powerful Method\nIf you call this method, you will receive the user's parent key for the protocol that they requested.\nWhen that happens, you are now managing a person's keys, and whatever assets they control, on their behalf.\nTheir safety is your responsibility.\n:::\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Parameters\n\n- `Object`\n  - `coinType` (`number`) - The BIP-44 coin type to get the entropy for.","metadata":{"source":"snaps-rpc-api"}}],["359",{"pageContent":"Returns\n\n```typescript\ninterface BIP44CoinTypeNode {\n  /**\n   * The BIP-44 `coin_type` value of this node.\n   */\n  readonly coin_type: number;\n\n  /**\n   * The 0-indexed BIP-44 path depth of this node.\n   *\n   * Since this is a `coin_type` node, it will be the number `2`.\n   */\n  readonly depth: 2;\n\n  /**\n   * The hexadecimal-encoded string representation of the private key for this node.\n   */\n  readonly privateKey: string;\n\n  /**\n   * The hexadecimal-encoded string representation of the public key for this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The hexadecimal-encoded string representation of the chain code for this node.\n   */\n  readonly chainCode: string;","metadata":{"source":"snaps-rpc-api"}}],["360",{"pageContent":"/**\n   * The hexadecimal-encoded string representation of the chain code for this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * A human-readable representation of the BIP-44 HD tree path of this node.\n   *\n   * Since this is a `coin_type` node, it will be of the form:\n   *\n   * `m / 44' / coin_type'`\n   *\n   * Recall that a complete BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  readonly path: string;\n}","metadata":{"source":"snaps-rpc-api"}}],["361",{"pageContent":"`BIP44CoinTypeNode` - An object representing the [BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) `coin_type` HD Tree node and containing its corresponding key material.","metadata":{"source":"snaps-rpc-api"}}],["362",{"pageContent":"Description\n\nGets the [BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) `coin_type` key for the `coin_type` number specified by the method name.\nThis is the \"key management\" permission of Snaps; use it with the utmost care.\nFor the authoritative list of available protocols and their `coin_type` values, see [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).\n\nThis restricted method is both implemented and designed to be used with [`@metamask/key-tree`](https://npmjs.com/package/@metamask/key-tree).\nSee the `@metamask/key-tree` documentation and below example for more information.\n\nNote that `@metamask/key-tree` can help you get the [extended private keys](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys) for user addresses, but it is your responsibility to know how to use those keys to e.g. derive an address for the relevant protocol or sign a transaction for the user.","metadata":{"source":"snaps-rpc-api"}}],["363",{"pageContent":"Example\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab Manifest\n\n```json\n{\n  \"initialPermissions\": {\n    \"snap_getBip44Entropy\": [\n      {\n        \"coinType\": 3\n      }\n    ]\n  }\n}","metadata":{"source":"snaps-rpc-api"}}],["364",{"pageContent":":::\n\n::: tab Code\n\n```javascript\nimport { getBIP44AddressKeyDeriver } from '@metamask/key-tree';\n\n// By way of example, we will use Dogecoin, which has `coin_type` 3.\nconst dogecoinNode = await snap.request({\n  method: 'snap_getBip44Entropy',\n  params: {\n    coinType: 3,\n  },\n});\n\n// Next, we'll create an address key deriver function for the Dogecoin coin_type node.\n// In this case, its path will be: m / 44' / 3' / 0' / 0 / address_index\nconst deriveDogecoinAddress = await getBIP44AddressKeyDeriver(dogecoinNode);\n\n// These are BIP-44 nodes containing the extended private keys for\n// the respective derivation paths.\n\n// m / 44' / 3' / 0' / 0 / 0\nconst addressKey0 = await deriveDogecoinAddress(0);\n\n// m / 44' / 3' / 0' / 0 / 1\nconst addressKey1 = await deriveDogecoinAddress(1);\n\n// Now, you can ask the user to e.g. sign transactions!\n```\n\n:::\n\n::::","metadata":{"source":"snaps-rpc-api"}}],["365",{"pageContent":"`snap_getBip32PublicKey`\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Parameters\n\n- `Object`\n  - `path` - An array, starting with `m`, containing the BIP-32 derivation path to the public key to retrieve, e.g., `[\"m\", \"44'\", \"60'\"]`.\n  - `curve` - The curve to use for the key derivation, must be `'ed25519'` or `'secp256k1'`.\n  - `compressed` - Whether the public key should be compressed. Defaults to `false`.\n\n#### Returns\n\nThe public key as hexadecimal `string`.\n\n#### Description\n\nGets the [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) public key for the derivation path\nspecified by the `path` parameter.\n\nNote that this returns the public key, not the extended public key (`xpub`), or (Ethereum) address.","metadata":{"source":"snaps-rpc-api"}}],["366",{"pageContent":"Example\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab Manifest\n\n```json\n{\n  \"initialPermissions\": {\n    \"snap_getBip32PublicKey\": [\n      {\n        \"path\": [\"m\", \"44'\", \"3'\", \"0'\", \"0\", \"0\"],\n        \"curve\": \"secp256k1\" // Or \"ed25519\"\n      }\n    ]\n  }\n}\n```\n\n:::\n\n::: tab Code\n\n```javascript\n// By way of example, we will use Dogecoin, which has a derivation path starting\n// with `m/44'/3'`.\nconst dogecoinPublicKey = await snap.request({\n  method: 'snap_getBip32PublicKey',\n  params: {\n    // The path and curve must be specified in the initial permissions.\n    path: ['m', \"44'\", \"3'\", \"0'\", '0', '0'],\n    curve: 'secp256k1',\n    compressed: false,\n  },\n});\n\n// `0x...`\nconsole.log(dogecoinPublicKey);\n```\n\n:::\n\n::::","metadata":{"source":"snaps-rpc-api"}}],["367",{"pageContent":"`snap_getEntropy`\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Parameters\n\n- `Object`\n  - `version` - The literal number `1`. This is reserved for future use.\n  - `salt` - An arbitrary string to be used as a salt for the entropy. This can be used to generate different entropy\n    for different purposes.\n\n#### Returns\n\nThe entropy as hexadecimal `string`.","metadata":{"source":"snaps-rpc-api"}}],["368",{"pageContent":"Returns\n\nThe entropy as hexadecimal `string`.\n\n#### Description\n\nGets a deterministic 256-bit entropy value, which is specific to the Snap and the user's account. This entropy can be\nused to generate a private key, or any other value that requires a high level of randomness. Other Snaps will not be\nable to access this entropy, and it will change if the user's secret recovery phrase changes.\n\nThis value is deterministic, meaning that it will always be the same for the same Snap, user account, and salt.\n\nYou can optionally specify a salt to generate different entropy for different purposes. Using a salt will result in\ncompletely different entropy, that is unrelated to the entropy generated without a salt.","metadata":{"source":"snaps-rpc-api"}}],["369",{"pageContent":"Example\n\n:::: tabs :options=\"{ useUrlFragment: false }\"\n\n::: tab Manifest\n\n```json\n{\n  \"initialPermissions\": {\n    \"snap_getEntropy\": {}\n  }\n}\n```\n\n:::\n\n::: tab Code\n\n```javascript\nconst entropy = await snap.request({\n  method: 'snap_getEntropy',\n  params: {\n    version: 1,\n    salt: 'foo', // Optional\n  },\n});\n\n// `0x...`\nconsole.log(entropy);\n```\n\n:::\n\n::::","metadata":{"source":"snaps-rpc-api"}}],["370",{"pageContent":"`snap_manageState`\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n::: tip Storage Limit\nSnaps can currently use this RPC method to store up to 100MB of data.\n:::\n\n#### Parameters\n\n- `Object`\n  - `operation` - `'clear' | 'get' | 'update'` - The state operation to perform.\n  - `newState` - `Record<string, unknown> | void` - The value to update state with if the operation is `update`, and nothing otherwise.\n\n#### Returns\n\n`null | Record<string, unknown>` - The value stored in state of the operation is `get`, and `null` otherwise.\n\n#### Description\n\nThis method allows the snap to persist some data to disk and retrieve it at will.\nThe data is automatically encrypted using a snap-specific key and automatically decrypted when retrieved.","metadata":{"source":"snaps-rpc-api"}}],["371",{"pageContent":"Example\n\n```javascript\n// First, let's persist some data\nawait snap.request({\n  method: 'snap_manageState',\n  params: { operation: 'update', newState: { hello: 'world' } },\n});\n\n// Then, at some later time, let's get the data we stored\nconst persistedData = await snap.request({\n  method: 'snap_manageState',\n  params: { operation: 'get' },\n});\n\nconsole.log(persistedData);\n// { hello: 'world' }\n\n// Finally, if there's no need to store data anymore, we can clear it out\nawait snap.request({\n  method: 'snap_manageState',\n  params: { operation: 'clear' },\n});\n```","metadata":{"source":"snaps-rpc-api"}}],["372",{"pageContent":"`snap_notify`\n\n::: warning Only Callable By\n\n- Snaps\n  :::\n\n#### Parameters\n\n```typescript\ninterface SnapNotifyParams {\n  /**\n   * Enum determining the notification type.\n   */\n  type: NotificationType;\n\n  /**\n   * A message to show in the notification.\n   */\n  message: string;\n}\n```\n\n- `Object` (`SnapNotifyParams`) - An object containing the contents of the notification.\n  - `type` - `'native' | 'inApp'` - Notification type to be used.\n  - `message` - Message to be displayed.\n\n#### Notification Type\n\n```typescript\nenum NotificationType {\n  /**\n   * A notification displayed in the MetaMask UI.\n   */\n  inApp = 'inApp',\n\n  /**\n   * A notification displayed in and by the browser. There is no guarantee that\n   * these will be displayed to the user, and we recommend using `inApp`\n   * notifications unless you have a compelling reason not to.\n   */\n  native = 'native',\n}\n```\n\n#### Returns\n\n`null` - This method doesn't return any data.","metadata":{"source":"snaps-rpc-api"}}],["373",{"pageContent":"Returns\n\n`null` - This method doesn't return any data.\n\n#### Description\n\nCalling this method displays a notification in MetaMask or natively in the browser.\nThe notification type and content are determined by the method's parameters.\nSee above for their meaning and format.\n\n#### Example\n\n```javascript\nawait snap.request({\n  method: 'snap_notify',\n  params: {\n    type: 'inApp',\n    message: `Hello, world!`,\n  },\n});\n```","metadata":{"source":"snaps-rpc-api"}}],["374",{"pageContent":"# Development Guide\n\n::: tip Developer Preview Software\n[Snaps](./snaps.html) is pre-release software. To try Snaps, install [MetaMask Flask](https://metamask.io/flask).\n:::\n\nDeveloping a snap is much like developing any JavaScript project, but there are some things that may be new even to a seasoned developer.\nRead on to learn more!\n\n## Table of Contents\n\n[[toc]]\n\n## The Snaps CLI\n\nBefore continuing, you should know that [`@metamask/snaps-cli`](https://www.npmjs.com/package/@metamask/snaps-cli) exists, and will be one of your most important tools as you get started with snap development.\nThe CLI can be installed globally using `npm` or `yarn`:\n\n```sh\nyarn global add @metamask/snaps-cli\n# or...\nnpm i -g @metamask/snaps-cli\n```\n\nThe CLI provides commands for initiating a snap project and building, executing, and serving your snap for local development.\nExecuting `mm-snap --help` will provide detailed usage instructions.","metadata":{"source":"snaps-development-guide"}}],["375",{"pageContent":"The Anatomy of a Snap\n\n::: warning Prerequisite Reading\nThis guide assumes that you've completed the [\"Getting Started\" tutorial](./snaps.html#getting-started).\n:::\n\nSo, you have installed [MetaMask Flask](https://metamask.io/flask), cloned the [@metamask/template-snap-monorepo](https://github.com/MetaMask/template-snap-monorepo) repository, and have served the \"Hello, World!\" snap locally.\nIt's time to develop your own snap.\n\nA snap is a JavaScript program that, conceptually, runs in a sandboxed environment inside MetaMask.\nAt the moment, snaps must be distributed as npm packages on the official npm registry (`https://registry.npmjs.org/`), but different distribution mechanisms will be supported in the future.\nIf you look at the directory structure of the template snap repository, you'll see that it looks something like this:","metadata":{"source":"snaps-development-guide"}}],["376",{"pageContent":"```text\ntemplate-snap-monorepo/\n├─ packages/\n│  ├─ site/\n|  |  |- src/\n|  |  |  |- App.tsx\n|  |  ├─ package.json\n|  |  |- ...(react app content)\n|  |\n│  ├─ snap/\n|  |  ├─ src/\n|  |  |  |- index.ts\n|  |  ├─ snap.manifest.json\n|  |  ├─ package.json\n|  |  |- ... (snap content)\n├─ package.json\n├─ ... (other stuff)","metadata":{"source":"snaps-development-guide"}}],["377",{"pageContent":"Source files other than `index.ts` are located through its imports.\nThe defaults can be overwritten using the `snap.config.js` [config file](#the-snap-configuration-file).\n\n::: tip Creating a Snap Project\nWhen you create a new snap project using `mm-snap init`, you'll notice that it will have all of these files.\nNevertheless, cloning the [template snap repository](https://github.com/MetaMask/template-snap-monorepo) is probably the best way to get started.\n:::\n\nIn this section, we'll review the major components of a snap: the source code, the manifest (and `package.json`), and the bundle file.","metadata":{"source":"snaps-development-guide"}}],["378",{"pageContent":"The Snap Source Code\n\nIf you're familiar with JavaScript or TypeScript development of any kind, developing a snap should feel quite familiar to you.\nConsider this trivial snap, which we'll call `hello-snap`:\n\n```javascript\nmodule.exports.onRpcRequest = async ({ origin, request }) => {\n  switch (request.method) {\n    // Expose a \"hello\" RPC method to Dapps\n    case 'hello':\n      return 'world!';\n\n    default:\n      throw new Error('Method not found.');\n  }\n};","metadata":{"source":"snaps-development-guide"}}],["379",{"pageContent":"In order to communicate with the outside world, the snap must implement its own JSON-RPC API by exposing an exported function called `onRpcRequest`.\nWhenever the snap receives a JSON-RPC request from an external entity (a Dapp or even another snap), this handler function will be called with the above parameters.\n\n::: warning Requesting the JSON-RPC permission\nIn order for the extension to call the `onRpcRequest` method of the snap, the `endowment:rpc` permission must be requested. See [Permissions](./snaps-permissions.html#endowment-rpc)\n:::\n\nIn addition to being able to expose a JSON-RPC API, snaps can access the global object `snap`.\nThis object can be used to make snap specific JSON-RPC requests.\n\nIf a Dapp wanted to use `hello-snap`, it would do something like this:\n\n```javascript\n// Connect to the Snap, enabling its usage inside the Dapp\nawait ethereum.request({\n  method: 'wallet_requestSnaps',\n  params: {\n    'npm:hello-snap': {\n      version: '^1.0.0',\n    },\n  },\n});","metadata":{"source":"snaps-development-guide"}}],["380",{"pageContent":"// Invoke the \"hello\" RPC method exposed by the Snap\nconst hello = await ethereum.request({\n  method: 'wallet_invokeSnap',\n  params: { snapId: 'npm:hello-snap', request: { method: 'hello' } },\n});\n\nconsole.log(hello); // 'world!'","metadata":{"source":"snaps-development-guide"}}],["381",{"pageContent":"The snap's RPC API is completely up to you, so long as it's a valid [JSON-RPC](https://www.jsonrpc.org/specification) API.\n\n::: tip Does my snap need to have an RPC API?\nWell, no, that's also up to you! If your snap can do something useful without receiving and responding to JSON-RPC requests, e.g., providing [transaction insights](./snaps-exports.html#ontransaction), then you can skip exporting `onRpcRequest`.\nHowever, if you want to do something like manage the user's keys for a particular protocol and create a Dapp that sends transactions for that protocol via your snap for example, you need to specify an RPC API.\n:::","metadata":{"source":"snaps-development-guide"}}],["382",{"pageContent":"The Snap Manifest\n\nIn order to get MetaMask to execute your snap, you need to have a valid manifest file, located in your package root directory under the name `snap.manifest.json`.\nThe manifest file of `hello-snap` would look something like this:\n\n```json\n{\n  \"version\": \"1.0.0\",\n  \"proposedName\": \"hello-snap\",\n  \"description\": \"A snap that says hello!\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/Hello/hello-snap.git\"\n  },\n  \"source\": {\n    \"shasum\": \"w3FltkDjKQZiPwM+AThnmypt0OFF7hj4ycg/kxxv+nU=\",\n    \"location\": {\n      \"npm\": {\n        \"filePath\": \"dist/bundle.js\",\n        \"iconPath\": \"images/icon.svg\",\n        \"packageName\": \"hello-snap\",\n        \"registry\": \"https://registry.npmjs.org/\"\n      }\n    }\n  },\n  \"initialPermissions\": {},\n  \"manifestVersion\": \"0.1\"\n}","metadata":{"source":"snaps-development-guide"}}],["383",{"pageContent":"The manifest tells MetaMask important information about your snap, most especially where it's published (via `source.location`) and how to verify the integrity of the snap source code (by attempting to reproduce the `source.shasum` value).\nFor the time being, snaps can only be [published to the official npm registry](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry), and the manifest must also match the corresponding fields of the `package.json` file.\nOver time, developers will be able to distribute snaps in a variety of different ways, and the manifest will expand to support different publishing solutions.\n\n::: tip The Snaps Publishing Specification\nThe [snaps publishing specification](https://github.com/MetaMask/SIPs/blob/main/SIPS/sip-9.md) details the requirements of both `snap.manifest.json` and its relationship to `package.json`.\n:::","metadata":{"source":"snaps-development-guide"}}],["384",{"pageContent":"In the course of developing your snap, you will have to modify some of the manifest fields manually.\nFor example, if you change the location of the (optional) icon SVG file, `source.location.npm.iconPath` must be updated to match.\nMeanwhile, the CLI will update some of the fields for you, e.g. `source.shasum` whenever you run `mm-snap build` (by default) or `mm-snap manifest --fix`.","metadata":{"source":"snaps-development-guide"}}],["385",{"pageContent":"The Snap Configuration File\n\n`snap.config.js` should be placed in the project root directory. It can override cli options - the property `cliOptions` should have string keys matching command arguments. Values become argument defaults, which can still be overridden on the command line. It would look something like this:\n\n```javascript\nmodule.exports = {\n  cliOptions: {\n    src: 'lib/index.js',\n    dist: 'out',\n    port: 9000,\n  },\n};","metadata":{"source":"snaps-development-guide"}}],["386",{"pageContent":"If you want to customize the Browserify build process, you can provide `bundlerCustomizer` property. It's a function that takes one argument, the [browserify object](https://github.com/browserify/browserify#api-example) which we use internally to bundle the snap. You can transform it in any way you want, for example adding plugins. The `bundleCustomizer` function would look something like this:\n\n```javascript\nconst brfs = require('brfs');\n\nmodule.exports = {\n  cliOptions: {\n    /* ... */\n  },\n  bundlerCustomizer: (bundler) => {\n    bundler.transform(brfs);\n  },\n};\n```\n\nThe configuration file should not be published to NPM, since it's only used for development and building. That being said, it can be committed to GitHub to share the configuration with your team, since it shouldn't contain any secrets.","metadata":{"source":"snaps-development-guide"}}],["387",{"pageContent":"The Snap Bundle File\n\nBecause of the way snaps are executed, they must be published as a single `.js` file containing the entire source code and all dependencies.\nMoreover, the [snaps execution environment](#the-snap-execution-environment) has no DOM, no Node.js APIs, and (needless to say) no filesystem access, so anything that relies on the DOM won't work, and any Node builtins have to be bundled along with the snap as well.\nIf this sounds like a lot to worry about, `mm-snap build` is your friend, because it will bundle your snap for you using [Browserify](https://browserify.org).\n\n`mm-snap build` will find all dependencies via your specified main entry point and output a bundle file to your specified output path.","metadata":{"source":"snaps-development-guide"}}],["388",{"pageContent":"Developing a Snap\n\nSnaps exist in order to modify the functionality of MetaMask at runtime while only asking the user for permission.\nAs we have seen in the [introduction to snaps](./snaps.html) and this guide, snaps can:\n\n1. Extend the Dapp-facing MetaMask JSON-RPC API in arbitrary ways.\n1. Integrate with and extend the functionality of MetaMask using the [snaps RPC methods and permissions](./snaps-rpc-api.html).\n\nIn this section, we'll go into detail about how to actually develop a snap and overcome common issues encountered during development.","metadata":{"source":"snaps-development-guide"}}],["389",{"pageContent":"The Snap Lifecycle\n\nBefore beginning the development of your snap, it's important to understand the snap lifecycle.\nJust like [service workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) or AWS lambda functions, snaps are designed to wake up in response to messages / events, and shut down when they are idle.\nWe say that snaps have an \"ephemeral\" lifecycle: here one moment, gone the next.\nIn addition, if MetaMask detects that a snap becomes unresponsive, it will be shut down.\nThis does not mean that you can't create long-running snaps, but it does mean that your snaps must handle being shut down, especially when they are not within the JSON-RPC request / response cycle.\n\nA snap is considered \"unresponsive\" if:\n\n1. It has not received a JSON-RPC request for 30 seconds.\n1. It takes more than 60 seconds to process a JSON-RPC request.","metadata":{"source":"snaps-development-guide"}}],["390",{"pageContent":"A snap is considered \"unresponsive\" if:\n\n1. It has not received a JSON-RPC request for 30 seconds.\n1. It takes more than 60 seconds to process a JSON-RPC request.\n\nStopped snaps are started whenever they receive a JSON-RPC request, unless they have been disabled.\nIf a snap is disabled, the user must re-enable it before it can start again.","metadata":{"source":"snaps-development-guide"}}],["391",{"pageContent":"Permissions\n\nJust like Dapps need to request the `eth_accounts` permission in order to access the user's Ethereum accounts, snaps need to request access to the sensitive methods in the snaps RPC API.\nSnaps can effectively expand the MetaMask RPC API by implementing their own and exposing it via `onRpcRequest`, but in order to integrate deeply with MetaMask, you need to make use of the Snaps RPC API's [restricted methods](./snaps-rpc-api.html#restricted-methods).\nAccess restriction is implemented using [EIP-2255 wallet permissions](https://eips.ethereum.org/EIPS/eip-2255), and you must specify the permissions required by your snap in the manifest's `initialPermissions` field.\nYou can find an example of how to do this in the [template snap's manifest](https://github.com/MetaMask/template-snap-monorepo/blob/main/packages/snap/snap.manifest.json).","metadata":{"source":"snaps-development-guide"}}],["392",{"pageContent":"Accessing the Internet\n\nSnaps do not get access to any sensitive APIs or features by default, and Internet access is no exception to that rule.\nTo access the Internet, you must specify the permission `endowment:network-access` in the `initialPermissions` of your `snap.manifest.json` file.\nThis will grant you access to the global `fetch` and `WebSocket` APIs.\nOther global network APIs may be made available in the future.\n\n::: tip \"Endowment\"?\nWhile most permission names correspond directly to JSON-RPC methods, permissions prefixed with `endowment:` are an exception.\nIn the language of the MetaMask permission system, an \"endowment\" is just a type of permission.\nAt the moment, we only use this permission type to enable snap internet access, but we may add other such permissions in the future.\n:::","metadata":{"source":"snaps-development-guide"}}],["393",{"pageContent":"The Snap User Interface\n\nAny snap will need to represent itself and what it does to the end user.\nVia the MetaMask settings page, the user can see their installed snaps. For each snap, the user can:\n\n- see most of its manifest data\n- see its execution status (running, stopped, or crashed)\n- enable and disable the snap\n\nOther than the settings page, there are only a few select ways a snap can modify the MetaMask UI:\n\n- By opening a dialog using the [`snap_dialog`](./snaps-rpc-api.html#snap-dialog) RPC method.\n- By returning transaction insights from the [`onTransaction`](./snaps-exports.md#ontransaction) export.\n\nThis means that most snaps will have to rely on web pages (i.e., Dapps) and their own RPC methods to present their data to the user.\n\nProviding more ways for snaps to modify the MetaMask UI is an important goal of the snaps system, and over time more and more snaps will be able to contain their user interfaces entirely within MetaMask itself.","metadata":{"source":"snaps-development-guide"}}],["394",{"pageContent":"Detecting the User's MetaMask Version\n\nWhen developing a website/Dapp that depends on Snaps, it's important to know whether MetaMask Flask is installed.\n\nWe recommend calling the [`web3_clientVersion`](https://metamask.github.io/api-playground/api-documentation/#web3_clientVersion) RPC method to obtain this information. Here we are using the [`@metamask/detect-provider`](https://npmjs.com/package/@metamask/detect-provider) package to get the provider object from MetaMask first:\n\n```js\nimport detectEthereumProvider from '@metamask/detect-provider';\n\n// This resolves to the value of window.ethereum or null\nconst provider = await detectEthereumProvider();\n\n// web3_clientVersion returns the installed MetaMask version as a string\nconst isFlask = (\n  await provider?.request({ method: 'web3_clientVersion' })\n)?.includes('flask');\n\nif (provider && isFlask) {\n  console.log('MetaMask Flask successfully detected!');","metadata":{"source":"snaps-development-guide"}}],["395",{"pageContent":"if (provider && isFlask) {\n  console.log('MetaMask Flask successfully detected!');\n\n  // Now you can use Snaps!\n} else {\n  console.error('Please install MetaMask Flask!', error);\n}\n```","metadata":{"source":"snaps-development-guide"}}],["396",{"pageContent":"The Snap Execution Environment\n\nSnaps execute in a sandboxed environment that's running Secure ECMAScript (SES, see [below](#secure-ecmascript-ses)).\nThere is no DOM, no Node.js builtins, and no platform-specific APIs other than MetaMask's `snap` global object.\nAlmost all standard JavaScript globals contained in [this list](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects) that are also in Node.js are available as normal.\nThis includes things like `Promise`, `Error`, `Math`, `Set`, `Reflect` etc.\n\nIn addition, the following globals are available:\n\n- `console`\n- `crypto`\n- `fetch` / `WebSocket` (with the [appropriate permission](#accessing-the-internet))\n- `setTimeout` / `clearTimeout`\n- `setInterval` / `clearInterval`\n- `SubtleCrypto`\n- `WebAssembly`\n- `TextEncoder` / `TextDecoder`\n- `atob` / `btoa`\n- `URL`\n\nThe execution environment is instrumented in this way to:","metadata":{"source":"snaps-development-guide"}}],["397",{"pageContent":"The execution environment is instrumented in this way to:\n\n1. Prevent snaps from influencing any other running code, including MetaMask itself.\n   - In plain terms, to prevent all snaps from polluting the global environment and malicious snaps from stealing the user's stuff.\n1. Prevent snaps from accessing sensitive JavaScript APIs (like `fetch`) without permission.\n1. Ensure that the execution environment is \"fully virtualizable\", i.e. platform-independent.\n\nThis allows us to safely execute snaps anywhere, without the snap needing to worry about where and how it is executed.","metadata":{"source":"snaps-development-guide"}}],["398",{"pageContent":"Secure ECMAScript (SES)\n\nSecure ECMAScript, or [SES](https://github.com/endojs/endo/tree/master/packages/ses), is effectively a subset of the JavaScript language designed to enable mutually suspicious programs to execute in the same JavaScript process (or more accurately, the same [realm](https://tc39.es/ecma262/#realm)).\nYou can think of it as a more severe form of [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).","metadata":{"source":"snaps-development-guide"}}],["399",{"pageContent":"Fixing Build / Eval Issues\n\nBecause SES adds additional restrictions on the JavaScript runtime on top of strict mode, code that executes normally under strict mode may not do so under SES.\n`mm-snap build` will by default attempt to execute your snap in a stubbed SES environment.\nYou can also disable this behavior and run the evaluation step separately using `mm-snap eval`.\nIf an error is thrown during this step, it is likely due to a SES incompatibility, and you have to fix the issues manually.\nIn our experience, these incompatibilities tend to occur in dependencies.","metadata":{"source":"snaps-development-guide"}}],["400",{"pageContent":"While the errors you get from SES may seem scary, they're usually not that hard to fix.\nThe actual file, function, and variable names in the `mm-snap eval` error stack trace may not make a lot of sense to you, but the line numbers should correspond to your snap bundle file.\nIn this way, you can identify if the error is due to your code or one of your dependencies.\nIf the problem is in a dependency, you can try a different version or to fix the issue locally by using tools such as [`patch-package`](https://npmjs.com/package/patch-package) or by modifying the snap bundle file directly.\n\n::: tip Patching Dependencies\nYou can read more about patching dependencies [here](./snaps-patching-dependencies.html)\n:::","metadata":{"source":"snaps-development-guide"}}],["401",{"pageContent":"::: tip Patching Dependencies\nYou can read more about patching dependencies [here](./snaps-patching-dependencies.html)\n:::\n\nTo give you an idea of a common error and how to fix it, \"sloppily\" declared variables (i.e. assigning to a new variable without an explicit variable declaration) are forbidden in strict mode, and therefore in SES as well.\nIf you get an error during the `eval` step that says something like `variableName is not defined`, simply prepending `var variableName;` to your snap bundle may solve the problem.\n(This actually happened so frequently with [Babel's](https://babeljs.io/) `regeneratorRuntime` that `mm-snap build` automatically handles that one.)\n\n::: warning Did you modify the snap bundle after building?\nDon't forget to run `mm-snap manifest --fix` if you modified your snap bundle after building.\nOtherwise your manifest `shasum` value won't be correct, and attempting to install your snap will fail.\n:::","metadata":{"source":"snaps-development-guide"}}],["402",{"pageContent":"If you run into a build or eval issue that you can't solve on your own, please create an issue on the [MetaMask/snaps-monorepo](https://github.com/MetaMask/snaps-monorepo) repository.","metadata":{"source":"snaps-development-guide"}}],["403",{"pageContent":"Using Other Build Tools\n\nIf you prefer building your snap with a build system you are more comfortable with, we have released severals plugins for other build systems that you can use. We currently support:\n\n- [Webpack](https://www.npmjs.com/package/@metamask/snaps-webpack-plugin)\n- [Rollup](https://www.npmjs.com/package/@metamask/rollup-plugin-snaps)\n- [Browserify](https://www.npmjs.com/package/@metamask/snaps-browserify-plugin)\n\nFor examples on how to set up these build systems yourself, please visit our [examples](https://github.com/MetaMask/snaps-monorepo/tree/main/packages/examples/examples).\n\nWe still recommend using our CLI `mm-snap` to make sure your manifest `shasum` value is correct by running `mm-snap manifest --fix` after creating your bundle. You may also benefit from running `mm-snap eval` to detect any SES issues up front.","metadata":{"source":"snaps-development-guide"}}],["404",{"pageContent":"Testing Your Snap\n\nTest your snap by hosting it locally using `mm-snap serve`, installing it in Flask, and calling its RPC methods from a web page.","metadata":{"source":"snaps-development-guide"}}],["405",{"pageContent":"Debugging Your Snap\n\nTo debug your snap, your best bet is to use `console.log` and inspecting the MetaMask background process.\nYou can add your log statements in your source coder and then build your snap, or add them directly to your snap bundle and use `mm-snap manifest --fix` to update the shasum in your snap manifest file.\nRecall that the manifest shasum must match the contents of your bundle at the time that MetaMask fetches your snap.\n\n::: tip Remember to Reinstall Your Snap\nBecause adding logs modifies the snap source code, you have to reinstall the snap whenever you add a log statement.\nThe process of reinstalling your snap during local development will improve in the next release of MetaMask Flask, and soon be available in prerelease builds.\n:::\n\nThe log output will only be visible in the extension background process console.\nFollow these instructions to inspect the background process and view its console:","metadata":{"source":"snaps-development-guide"}}],["406",{"pageContent":"The log output will only be visible in the extension background process console.\nFollow these instructions to inspect the background process and view its console:\n\n- Chromium\n  - Go to `chrome://extensions`\n  - Find the MetaMask extension\n  - Click on \"Details\"\n  - Turn on \"Developer Mode\" (top right)\n  - Under \"Inspect Views\", click `background.html`","metadata":{"source":"snaps-development-guide"}}],["407",{"pageContent":"Publishing Your Snap\n\nSnaps are npm packages, so publishing a Snap is as simple as publishing an npm package.\nRefer to the [npm cli documentation](https://docs.npmjs.com/cli/v8/commands/npm-publish) for details on publishing to the public registry.\nTake note of the following details specific to Snaps:\n\n- The version in `package.json` and `snap.manifest.json` must match\n- The image specified in `iconPath` in the manifest file will be used as the icon displayed when installing and displaying confirmations from the Snap\n\nAfter publishing the Snap, any Dapp can connect to the Snap by using the snapId `npm:[packageName]`.","metadata":{"source":"snaps-development-guide"}}],["408",{"pageContent":"Distributing Your Snap\n\nSince snaps are currently intended for a developer audience, MetaMask does not currently facilitate distributing snaps to a wide audience.\nIf you have a website that expects the user to install a snap, ask the user to install MetaMask Flask, and then ask the user to install the snap using the [`wallet_requestSnaps`](./snaps-rpc-api.html#wallet-requestsnaps) RPC method.\n\nIn the future, MetaMask will create some way for users to more easily discover snaps, but everyone will always be able to build, publish, and use snaps without MetaMask's permission.\n(Although we may try to make it difficult to use known scams.)","metadata":{"source":"snaps-development-guide"}}],["409",{"pageContent":"Resources and Tools\n\nYou can review the growing number of [example snaps](https://github.com/MetaMask/snaps-monorepo/tree/main/packages/examples) maintained by MetaMask, as well as the following reference Snaps. Each one is fully-functional and open-source:\n\n- [StarkNet](https://github.com/ConsenSys/starknet-snap)\n- [FilSnap for Filecoin](https://github.com/Chainsafe/filsnap/)\n- [Password Manager Snap](https://github.com/ritave/snap-passwordManager)\n- [Transaction Simulation with Ganache](https://github.com/Montoya/tx-simulation-with-ganache-snap) (uses Truffle for local testing)\n\nYou can also follow these tutorials which will walk you through the steps to develop and test a Snap:","metadata":{"source":"snaps-development-guide"}}],["410",{"pageContent":"You can also follow these tutorials which will walk you through the steps to develop and test a Snap:\n\n- A 5-minute tutorial that uses the `network-access` permission: [Gas Fee Snap Tutorial](https://github.com/Montoya/gas-fee-snap#readme)\n- A 30-minute tutorial that uses the `manageState` permission: [Address Book Snap Tutorial](https://github.com/Montoya/address-book-snap-tutorial#readme)\n- A 45-minute tutorial that shows you how to build a transaction insights snap: [4byte API snap video](https://archive.devcon.org/archive/watch/6/getting-started-with-metamask-snaps/?tab=YouTube) and [text guide](https://hackmd.io/@rekmarks/devcon-vi)\n\nMetaMask also maintains tools to help developers build, debug, and maintain snaps:","metadata":{"source":"snaps-development-guide"}}],["411",{"pageContent":"MetaMask also maintains tools to help developers build, debug, and maintain snaps:\n\n- [Template Snap](https://github.com/MetaMask/template-snap-monorepo) - A template that includes TypeScript/React and vanilla JS options and a CLI for building, packaging, and deploying your snap and a companion Dapp\n- [Snaps Truffle Box](https://trufflesuite.com/boxes/metamask-snap-box/) - A template that combines the TypeScript template snap and Truffle so you can easily test snaps that use smart contracts with Ganache\n- [Test Snaps](https://github.com/MetaMask/test-snaps) - A collection of test snaps and a Dapp for evaluating them\n\nFinally, if you need help, you can ask for help on our [discussion board](https://github.com/MetaMask/snaps-monorepo/discussions), and if you encounter any issues, please open an issue in our [issue tracker](https://github.com/MetaMask/snaps-monorepo/issues).","metadata":{"source":"snaps-development-guide"}}]]